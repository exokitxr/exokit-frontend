<!doctype html>
<html>
  <head>
    <style>
body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  overflow: hidden;
}
#canvas {
  width: 100vw;
  height: 100vh;
}
iframe, audio {
  display: none;
}
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script>
    <script src="BufferGeometryUtils.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="bmfont.js"></script>
    <script src="keycode.js"></script>
    <script src="svg-boundings.js"></script>
    <script src="cubicBezier.js"></script>
    <script src="sprite3d.js"></script>
    <script src="skin.js"></script>
    <script src="xrmp.js"></script>
    <script src="xrmp-three.js"></script>
    <script>
(async () => {
let display, fakeXrDisplay, tabs = [], tabId = 0, xrmp, lastPresseds = [false, false], lastAxes = [[0.5, 0.5], [0.5, 0.5]], lastPadToucheds = [false, false], scrollFactors = [0, 0], scaleFactors = [1, 1], viewport = new THREE.Vector4(0, 0, 1, 1), menuOpen = false, menuCoords = [new THREE.Vector2(-1, -1), new THREE.Vector2(-1, -1)], orbitControls, transformControls, rooms = [], pendingRooms = [null, null], roomLinks = [], roomDiagrams = [], roomLabels = [], volumeMeshes = [], portalMeshes = [], menuAnimation = null;
const viewMatrices = [
  new THREE.Matrix4(),
  new THREE.Matrix4(),
];
const projectionMatrices = [
  new THREE.Matrix4(),
  new THREE.Matrix4(),
];
const cameraViewport = [0, 0];

const links = [
  {
    id: 'webXrSample',
    name: 'WebXR Sample',
    url: 'https://rawcdn.githack.com/exokitxr/webxr-samples/a8e2c94eba0ee5c9215f20d13057b6c25675d9b0/xr-presentation.html',
  },
  {
    id: 'kitchenSink',
    name: 'Kitchen sink',
    url: 'hello_ml.html',
  },
  {
    id: 'tutorial',
    name: 'Tutorial',
    url: 'tutorial.html',
  },
  {
    id: 'exobot',
    name: 'Exobot',
    url: 'exobot.html',
  },
  {
    id: 'meshing',
    name: 'Meshing',
    url: 'meshing_ml.html',
  },
  {
    id: 'planes',
    name: 'Planes',
    url: 'planes_ml.html',
  },
  {
    id: 'paint',
    name: 'Paint',
    url: 'paint_ml.html',
  },
  {
    id: 'hitTest',
    name: 'Hit test',
    url: 'graffiti_ml.html',
  },
  {
    id: 'hands',
    name: 'Hands',
    url: 'hands_ml.html',
  },
  {
    id: 'eyeTracking',
    name: 'Eye tracking',
    url: 'eyetracking_ml.html',
  },
  {
    id: 'minimap',
    name: 'Minimap',
    url: 'minimap_ml.html',
  },
  {
    id: 'avatar',
    name: 'Avatar',
    url: 'avatar_ml.html',
  },
  {
    id: 'shooter',
    name: 'Shooter',
    url: 'shooter_ml.html',
  },
  {
    id: 'sword',
    name: 'Sword',
    url: 'sword_ml.html',
  },
  {
    id: 'bow',
    name: 'Bow',
    url: 'bow_ml.html',
  },
  {
    id: 'pathfinding',
    name: 'Pathfinding',
    url: 'pathfinding_ml.html',
  },
  {
    id: 'radar',
    name: 'Radar',
    url: 'radar_ml.html',
  },
  {
    id: 'imageTracking',
    name: 'Image tracking',
    url: 'imagetracking_ml.html',
  },
  {
    id: 'microphone',
    name: 'Microphone',
    url: 'microphone.html',
  },
  {
    id: 'blank',
    name: 'Blank',
    url: 'blank.html',
  },
  {
    id: 'aframe',
    name: 'A-Frame',
    url: 'aframe.html',
  },
  {
    id: 'babylon',
    name: 'Babylon.js',
    url: 'babylon.html',
  },
].map(({id, name, url}) => ({id, name, url, iconMesh: null}));
let servers = [];
let serversLoading = false;
let serverConnectedUrl = null;

const DEFAULT_URL = 'http://lol.com';
const DEFAULT_REGISTRY_URL = 'http://xrmp.exokit.org:9001';
const DEFAULT_SKIN_URL = 'skin2.png';
const RAY_COLOR = 0x44c2ff;
const RAY_HIGHLIGHT_COLOR = new THREE.Color(RAY_COLOR).multiplyScalar(0.5).getHex();
const rayDistance = 3;
const menuWidth = 1024;
const menuHeight = menuWidth * 0.1;
const menuWorldWidth = 1;
const menuWorldHeight = menuWorldWidth / menuWidth * menuHeight;
const menuPositionHeight = 0.3;
const urlBarWidth = menuWorldWidth;
const urlBarHeight = menuHeight;
const urlBarOffset = urlBarHeight;
const fontFamily = 'Arial';
// const fontFamily = 'monospace';
const fontSize = 60;
const keyboardWidth = 2048;
const keyboardHeight = 716;
const keyboardMatrix = [keyboardWidth / 963.266, keyboardHeight / 337.215];
const cursorWidth = 4;
const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localVector2D = new THREE.Vector2();
const localQuaternion = new THREE.Quaternion();
const localQuaternion2 = new THREE.Quaternion();
const localEuler = new THREE.Euler(0, 0, 0, 'YXZ');
const localEuler2 = new THREE.Euler(0, 0, 0, 'YXZ');
const localMatrix = new THREE.Matrix4();
const localLine = new THREE.Line3();
const localRay = new THREE.Ray();
const localRaycaster = new THREE.Raycaster();
const localPlane = new THREE.Plane();

function parseQuery(s) {
  var query = {};
  var pairs = (s[0] === '?' ? s.substr(1) : s).split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  return query;
}
const query = parseQuery(window.location.search);
const registryUrl = query.registryUrl || DEFAULT_REGISTRY_URL;

// load

const keyMap = [];
fetch('keyboard.svg')
  .then(res => res.text())
  .then(keyboardText => {
    const div = document.createElement('div');
    div.innerHTML = keyboardText;
    const keyEls = div.querySelectorAll('svg > g[key]');
    for (let i = 0; i < keyEls.length; i++) {
      const keyEl = keyEls[i];
      const key = keyEl.getAttribute('key');
      const shapeEl = keyEl.children[0];
      const boundings = svgBoundings[shapeEl.tagName.toLowerCase()](shapeEl);
      const {
        left,
        right,
        top,
        bottom,
      } = boundings;
      const x1 = left * keyboardMatrix[0];
      const x2 = right * keyboardMatrix[0];
      const y1 = top * keyboardMatrix[1];
      const y2 = bottom * keyboardMatrix[1];
      keyMap.push([key, x1, y1, x2, y2]);
    }
  })
  .catch(err => {
    console.warn(err.stack);
  });

let keyboardHighlightCanvasCtx = null;
new Promise((accept, reject) => {
  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.src = 'keyboard-highlight.png';
  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    accept(ctx);
  };
  img.onerror = err => {
    reject(err);
  };
})
  .then(ctx => {
    keyboardHighlightCanvasCtx = ctx;
  })
  .catch(err => {
    console.warn(err.stack);
  });

const iconMeshes = [];

const _requestSpriteMesh = url => new Promise((accept, reject) => {
  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.src = url;
  img.onload = () => {
    const spriteMesh = sprite3d.makeSpriteMesh(img);
    accept(spriteMesh);
  };
  img.onerror = err => {
    reject(err);
  };
});

const _makeBoxGeometry = (x = 1, y = 1, z = 1) => {
  const size = 1;
  const width = 0.005;

  const lineGeometry = new THREE.CylinderBufferGeometry(width, width, size, 3, 1);
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(lineGeometry.attributes.position.array.length * 12);
  geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, 0, -size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 0
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, 0, -size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 1
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, 0, size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 2
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, 0, size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 3
  );
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, -size/2, -size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 4
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, -size/2, size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 5
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, size/2, -size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 6
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, size/2, size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 7
  );
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, -size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 8
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 9
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, -size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 10
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 11
  );
  const numLinePositions = lineGeometry.attributes.position.array.length / 3;
  const indices = new Uint16Array(lineGeometry.index.array.length * 12);
  for (let i = 0; i < 12; i++) {
    indices.set(
      lineGeometry.index.array,
      lineGeometry.index.array.length * i
    );

    for (let j = 0; j < lineGeometry.index.array.length; j++) {
      lineGeometry.index.array[j] += numLinePositions;
    }
  }
  geometry.setIndex(new THREE.BufferAttribute(indices, 1));
  return geometry;
};
const boxMaterial = new THREE.MeshPhongMaterial({
  color: 0x333333,
});
const _makeBoxMesh = () => {
  const geometry = _makeBoxGeometry();
  const material = boxMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  return mesh;
};

const _parseVector = s => Array.isArray(s) ? s : s.split(' ').map(s => parseFloat(s));

const _mod = (v, d) => {
  const n = v % d;
  return n < 0 ? (d + n) : n;
};
const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;
const _makeSkinMesh = () => {
  const object = {};
  let onupdate = null;
  const uniforms = THREE.UniformsUtils.clone(skin.SKIN_SHADER.uniforms);
  object.setSkinUrl = skinUrl => {
    if (skinUrl) {
      const mesh = skin({
        limbs: true,
      });
      mesh.frustumCulled = false;

      mesh.onBeforeRender = (onBeforeRender => function() {
        mesh.material.uniforms.headRotation.value.copy(uniforms.headRotation.value);
        mesh.material.uniforms.leftArmRotation.value.copy(uniforms.leftArmRotation.value);
        mesh.material.uniforms.rightArmRotation.value.copy(uniforms.rightArmRotation.value);
        mesh.material.uniforms.theta.value = uniforms.theta.value;
        mesh.material.uniforms.headVisible.value = uniforms.headVisible.value;
        mesh.material.uniforms.hit.value = uniforms.hit.value;

        onBeforeRender.apply(this, arguments);
      })(mesh.onBeforeRender);

      return new Promise((accept, reject) => {
        const skinImg = new Image();
        skinImg.crossOrigin = 'Anonymous';
        skinImg.src = skinUrl;
        skinImg.onload = () => {
          accept(skinImg);
        };
        skinImg.onerror = err => {
          reject(err);
        };
      })
        .then(skinImg => {
          mesh.setImage(skinImg);

          onupdate = (hmd, gamepads) => {
            const hmdEuler = localEuler.setFromQuaternion(hmd.quaternion, localEuler.order);
            const playerEuler = localEuler2.setFromQuaternion(mesh.quaternion, localEuler2.order);
            const angleDiff = _angleDiff(hmdEuler.y, playerEuler.y);
            const angleDiffAbs = Math.abs(angleDiff);
            if (angleDiffAbs > Math.PI / 2) {
              playerEuler.y += (angleDiffAbs - (Math.PI / 2)) * (angleDiff < 0 ? 1 : -1);
              mesh.quaternion.setFromEuler(playerEuler);
            }

            const oldWorldPosition = mesh.getWorldPosition(localVector);
            mesh.position.copy(hmd.position)
              .sub(mesh.eye.getWorldPosition(localVector2))
              .add(oldWorldPosition);

            const playerQuaternionInverse = localQuaternion.copy(mesh.quaternion).inverse();
            mesh.head.quaternion.copy(playerQuaternionInverse).multiply(hmd.quaternion);
            mesh.updateMatrixWorld();

            const headQuaternionInverse = localQuaternion2.copy(mesh.head.quaternion).inverse();
            uniforms.headRotation.value.set(headQuaternionInverse.x, headQuaternionInverse.y, headQuaternionInverse.z, headQuaternionInverse.w);

            for (let i = 0; i < 2; i++) {
              const armRotation = uniforms[i === 0 ? 'leftArmRotation' : 'rightArmRotation'];

              const gamepad = gamepads[i];
              if (gamepad.visible) {
                const armQuaternionInverse = localQuaternion2.setFromRotationMatrix(
                  localMatrix.lookAt(
                    mesh.arms[i === 0 ? 'left' : 'right']
                      .getWorldPosition(localVector),
                    gamepad.position,
                    localVector2
                      .set(0, 1, 0)
                      .applyQuaternion(gamepad.quaternion)
                  )
                )
                  .multiply(armQuaternionOffset)
                  .premultiply(playerQuaternionInverse)
                  .inverse();
                armRotation.value.set(armQuaternionInverse.x, armQuaternionInverse.y, armQuaternionInverse.z, armQuaternionInverse.w);
              } else {
                armRotation.value.set(0, 0, 0, 1);
              }
            }
          };

          if (object.skinMesh) {
            object.skinMesh.parent.remove(object.skinMesh);
            object.skinMesh = null;
          }

          scene.add(mesh);
          object.skinMesh = mesh;
        });
    } else {
      onupdate = null;

      if (object.skinMesh) {
        object.skinMesh.parent.remove(object.skinMesh);
        object.skinMesh = null;
      }
    }
  };
  object.update = (hmd, gamepads) => {
    onupdate && onupdate(hmd, gamepads);
  };
  object.animate = thetaValue => {
    uniforms.theta.value = thetaValue;
  };
  object.destroy = () => {
    onupdate = null;

    if (object.skinMesh) {
      object.skinMesh.parent.remove(object.skinMesh);
      object.skinMesh = null;
    }
  };
  object.skinMesh = null;
  return object;
};
/* const localSkinMesh = _makeSkinMesh();
localSkinMesh.setSkinUrl(DEFAULT_SKIN_URL) */

const _makePositionSnapshotter = () => {
  const numSnapshots = 8;
  const positionShapshots = Array(numSnapshots);
  for (let i = 0; i < positionShapshots.length; i++) {
    positionShapshots[i] = {
      position: new THREE.Vector3(),
      timestamp: 0,
    };
  }
  let positionShapshotIndex = 0;
  let positionShapshotsInitialized = false;

  return {
    capturePositionSnapshot(position, timestamp) {
      const snapshot = positionShapshots[positionShapshotIndex];
      snapshot.position.copy(position);
      snapshot.timestamp = timestamp;

      positionShapshotIndex = (positionShapshotIndex + 1) % positionShapshots.length;
    },
    getFirstPosition() {
      return positionShapshots[positionShapshotIndex];
    },
    getLastPosition() {
      let index = positionShapshotIndex - 1;
      if (index < 0) {
        index += positionShapshots.length;
      }
      return positionShapshots[index];
    },
  };
};

// helpers

const _getFrontOfCamera = () => {
  const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
  vrCamera.matrixWorld.decompose(localVector, localQuaternion, localVector2);
  localVector.add(
    localVector2.set(0, 0, -1.5)
      .applyQuaternion(localQuaternion)
  );
  localVector2.set(1, 1, 1);

  return {
    position: localVector.clone(),
    quaternion: localQuaternion.clone(),
    scale: localVector2.clone(),
  };
};

const _openUrl = (u, position = new THREE.Vector3(), orientation = new THREE.Quaternion(), scale, d = 3, local = true, id = tabId++) => {
  if (scale === undefined) {
    scale = new THREE.Vector3(1, d === 3 ? 1 : window.innerHeight/window.innerWidth, 1);
    if (d !== 3) {
      scale.multiplyScalar(0.4);
    }
  }

  const _drawOk = () => {
    console.log('reality tab load ok: ' + u);

    _pushDomUpdate();
  };
  const _drawFail = () => {
    console.log('reality tab load error: ' + u);
  };

  const iframe = document.createElement('iframe');
  iframe.onconsole = (jsString, scriptUrl, startLine) => {
    console.log('parent got console', {jsString, scriptUrl, startLine});
  };
  iframe.onload = function() {
    const contentDocument = (() => {
      try {
        if (this.contentDocument) { // this potentially throws
          return this.contentDocument;
        } else {
          return null;
        }
      } catch(err) {
        console.warn(err.stack);
        return null;
      }
    })();
    if (contentDocument) {
      _drawOk();
    } else {
      _drawFail();

      _closeTab(tab);

      if (focusedTab === tab) {
        focusedTab = rig.menuMesh.urlMesh;
      }

      rig.menuMesh.urlMesh.updateText();
      _updateRigLists();
    }
  };
  iframe.d = d;
  iframe.src = u;

  const tab = _addTab(iframe, position, orientation, scale, d, local, id);
};
const _addTab = (iframe, position = new THREE.Vector3(), orientation = new THREE.Quaternion(), scale, d = 3, local = true, id = tabId++) => {
  if (scale === undefined) {
    scale = new THREE.Vector3(1, d === 3 ? 1 : window.innerHeight/window.innerWidth, 1);
    if (d !== 3) {
      scale.multiplyScalar(0.4);
    }
  }

  iframe.position = position.toArray();
  iframe.orientation = orientation.toArray();
  iframe.scale = scale.toArray();

  document.body.appendChild(iframe);

  const tab = {
    url: iframe.src,
    id,
    iframe,
  };
  tabs.push(tab);
  layers.push(iframe);

  focusedTab = tab;

  rig.menuMesh.urlMesh.updateText();
  rig.menuMesh.listMesh.updateList();

  if (serverConnectedUrl && local) {
    const objectMesh = xrmp.createObjectMesh(tab.id, {
      url: tab.url,
      d,
    });
    const {object} = objectMesh;
    position.toArray(object.objectMatrix.position);
    orientation.toArray(object.objectMatrix.quaternion);
    object.pushUpdate();
    _bindObject(object);
  }

  return tab;
};
const _closeTab = tab => {
  document.body.removeChild(tab.iframe);
};
const _closeAllTabs = () => { // XXX trigger this when switching servers
  for (let i = 0; i < tabs.length; i++) {
    const {iframe} = tabs[i];
    if (iframe.destroy) {
      iframe.destroy();
    }
    document.body.removeChild(iframe);
  }

  tabs.length = 0;
  layers.length = 0;
};
const _openServer = (serverUrl, host) => {
  xrmp = new XRMultiplayerTHREE(new XRMultiplayer(serverUrl));
  xrmp.localPlayerMesh = null;
  xrmp.onopen = () => {
    xrmp.localPlayerMesh = xrmp.createLocalPlayerMesh(undefined, {});

    if (host) {
      for (let i = 0; i < tabs.length; i++) {
        const tab = tabs[i];
        const {url, iframe: {xrOffset, d}} = tab;
        const objectMesh = xrmp.createObjectMesh(tab.id, {
          url,
          d,
        });
        const {object} = objectMesh;
        object.objectMatrix.position.set(xrOffset.position);
        object.objectMatrix.quaternion.set(xrOffset.orientation);
        object.pushUpdate();
        _bindObject(object);
      }
    }
  };
  xrmp.onsync = () => {
    console.log('server sync', serverUrl);

    serverConnectedUrl = serverUrl;
    rig.menuMesh.listMesh.updateList();
  };
  xrmp.onclose = () => {
    console.log('server close', serverUrl);

    xrmp = null;
    serverConnectedUrl = null;
    rig.menuMesh.listMesh.updateList();
  };
  xrmp.onobjectadd = objectMesh => {
    const {object} = objectMesh;
    const {id, state} = object;
    if (!tabs.some(tab => tab.id === id)) {
      const {url, d} = state;
      _openUrl(url, undefined, undefined, undefined, d, false, id);
      _bindObject(object);
      console.log('server object add', id);
    } else {
      console.warn('ignoring duplicate server tab', id);
    }
  };
  xrmp.onobjectremove = objectMesh => {
    const {id} = objectMesh.object;
    const index = tabs.findIndex(tab => tab.id === id);
    if (index !== -1) {
      tabs.splice(index, 1);
      console.log('server object remove', id);
    } else {
      console.warn('failed to remove local server tab', id);;
    }
  };
  xrmp.onplayerenter = playerMesh => {
    const skinMesh = _makeSkinMesh();
    skinMesh.setSkinUrl(DEFAULT_SKIN_URL);
    playerMesh.skinMesh = skinMesh;

    const positionSnapshotter = _makePositionSnapshotter();
    playerMesh.onupdate = () => {
      skinMesh.update(playerMesh.hmd, playerMesh.gamepads);

      localVector.copy(playerMesh.hmd.position);
      localVector.y = 0;
      positionSnapshotter.capturePositionSnapshot(localVector, Date.now());
    };
    playerMesh.animate = () => {
      const walkRate = 1000;
      const f = (Date.now() % walkRate) / walkRate;
      const firstPosition = positionSnapshotter.getFirstPosition();
      const lastPosition = positionSnapshotter.getLastPosition();
      const walkSpeed = localVector.copy(firstPosition.position)
        .distanceTo(lastPosition.position) / (lastPosition.timestamp - firstPosition.timestamp);
      const walkIntensity = Math.min(walkSpeed * 1000, 1);
      const thetaValue = Math.sin(f * Math.PI*2) * walkIntensity * 0.7;
      skinMesh.animate(thetaValue);
    };

    scene.add(playerMesh);
  };
  xrmp.onplayerleave = playerMesh => {
    scene.remove(playerMesh);

    playerMesh.skinMesh.destroy();
  };
  xrmp.onerror = e => {
    console.warn(e.error);
  };
};
const _closeServer = () => {
  xrmp.onopen = null;
  xrmp.onsync = null;
  xrmp.onobjectadd = null;
  xrmp.onobjectremove = null;
  xrmp.close();
};
const _bindObject = o => {
  o.onupdate = e => {
    const {object, matrix} = e;
    const {id} = object;
    const tab = tabs.find(tab => tab.id === id);
    const {iframe} = tab;
    iframe.position = Array.from(matrix.position);
    iframe.orientation = Array.from(matrix.quaternion);
  };
};
const _updateRigLists = () => {
  const {menuMesh} = rig;
  if (menuMesh.listMesh.scrollIndex < 0) {
    menuMesh.listMesh.scrollIndex = 0;
  } else {
    const items = menuMesh.optionsMesh.list === 'tabs' ? tabs : links;
    if (menuMesh.listMesh.scrollIndex > items.length - 1) {
      menuMesh.listMesh.scrollIndex = items.length - 1;
    }
  }
  menuMesh.listMesh.updateList();
};

// main

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0x7E57C2);
scene.matrixAutoUpdate = false;

/* const cubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0xab47bc,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z = -5;
  mesh.rotation.order = 'YXZ';
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(cubeMesh); */

const sphereMesh = (() => {
  const geometry = new THREE.SphereBufferGeometry(500, 300, 300)
    .applyMatrix(new THREE.Matrix4().makeScale(-1, -1, -1));
  const material = new THREE.MeshBasicMaterial({
    color: 0x000000,
  });
  const mesh = new THREE.Mesh(geometry, material);
  return mesh;
})();
scene.add(sphereMesh);

const fontSpec = await Promise.all([
  fetch('DejaVu-sdf.json').then(res => res.json()),
  new Promise((accept, reject ) => {
    new THREE.TextureLoader().load('DejaVu-sdf.png', accept);
  }),
]).then(([font, texture]) => ({font, texture}));
const _makeTextMesh = (s = '', size = 1) => {
  const {font, texture} = fontSpec;

  // create a geometry of packed bitmap glyphs, 
  // word wrapped to 300px and right-aligned
  var geometry = createTextGeometry({
    width: 1000,
    // width: 300,
    font,
  });

  // change text and other options as desired
  // the options sepcified in constructor will
  // be used as defaults
  geometry.update(s)

  // the resulting layout has metrics and bounds
  // console.log(geometry.layout.height)
  // console.log(geometry.layout.descender)

  var material = new THREE.RawShaderMaterial(createSDFShader({
    map: texture,
    transparent: true,
    color: 0xffffff,
    // color: palette[Math.floor(Math.random() * palette.length)]
    // negate: false,
    side: THREE.DoubleSide,
  }));

  const scaleFactor = 0.001 * size;

  var mesh = new THREE.Mesh(geometry, material)
  mesh.position.set(0, -geometry.layout.height * scaleFactor, 0);
  mesh.scale.set(scaleFactor, -scaleFactor, -scaleFactor);
  return mesh;
};
const textMesh = _makeTextMesh('Lorem ipsum dolor sit amet');
textMesh.position.x -= 0.5;
textMesh.position.y += 1;
textMesh.frustumCulled = false;
scene.add(textMesh);

/* const skyShader = {

	uniforms: {

		luminance: { value: 1 },
		turbidity: { value: 2 },
		rayleigh: { value: 1 },
		mieCoefficient: { value: 0.005 },
		mieDirectionalG: { value: 0.8 },
		sunPosition: { value: new THREE.Vector3() }

	},

	vertexShader: [

		"uniform vec3 sunPosition;",
		"uniform float rayleigh;",
		"uniform float turbidity;",
		"uniform float mieCoefficient;",

		"varying vec3 vWorldPosition;",
		"varying vec3 vSunDirection;",
		"varying float vSunfade;",
		"varying vec3 vBetaR;",
		"varying vec3 vBetaM;",
		"varying float vSunE;",

		"const vec3 up = vec3(0.0, 1.0, 0.0);",

		// constants for atmospheric scattering
		"const float e = 2.71828182845904523536028747135266249775724709369995957;",
		"const float pi = 3.141592653589793238462643383279502884197169;",

		// mie stuff
		// K coefficient for the primaries
		"const float v = 4.0;",
		"const vec3 K = vec3(0.686, 0.678, 0.666);",

		// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness
		// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE
		"const vec3 simplifiedRayleigh = 0.0005 / vec3(94, 40, 18);",

		// wavelength of used primaries, according to preetham
		"const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);",

		// earth shadow hack
		"const float cutoffAngle = pi/1.95;",
		"const float steepness = 1.5;",
		"const float EE = 1000.0;",

		"float sunIntensity(float zenithAngleCos)",
		"{",
			"zenithAngleCos = clamp(zenithAngleCos, -1.0, 1.0);",
			"return EE * max(0.0, 1.0 - pow(e, -((cutoffAngle - acos(zenithAngleCos))/steepness)));",
		"}",

		"vec3 totalMie(vec3 lambda, float T)",
		"{",
			"float c = (0.2 * T ) * 10E-18;",
			"return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;",
		"}",

		"void main() {",

			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"vWorldPosition = worldPosition.xyz;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"vSunDirection = normalize(sunPosition);",

			"vSunE = sunIntensity(dot(vSunDirection, up));",

			"vSunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);",

			"float rayleighCoefficient = rayleigh - (1.0 * (1.0-vSunfade));",

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			"vBetaR = simplifiedRayleigh * rayleighCoefficient;",

			// mie coefficients
			"vBetaM = totalMie(lambda, turbidity) * mieCoefficient;",

		"}",

	].join( "\n" ),

	fragmentShader: [

		"varying vec3 vWorldPosition;",
		"varying vec3 vSunDirection;",
		"varying float vSunfade;",
		"varying vec3 vBetaR;",
		"varying vec3 vBetaM;",
		"varying float vSunE;",

		"uniform float luminance;",
		"uniform float mieDirectionalG;",

		"const vec3 cameraPos = vec3(0., 0., 0.);",

		// constants for atmospheric scattering
		"const float pi = 3.141592653589793238462643383279502884197169;",

		"const float n = 1.0003;", // refractive index of air
		"const float N = 2.545E25;", // number of molecules per unit volume for air at
									// 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		"const float rayleighZenithLength = 8.4E3;",
		"const float mieZenithLength = 1.25E3;",
		"const vec3 up = vec3(0.0, 1.0, 0.0);",

		// "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
		// 66 arc seconds -> degrees, and the cosine of that
		"const float sunAngularDiameterCos = cos(0.0277778);",
		// 100 arc seconds -> degrees, and the cosine of that

		"float powClamp(float f, float e)",
		"{",
			"return pow(max(f, 0.0), e);",
		"}",
		"vec3 powClamp(vec3 f, vec3 e)",
		"{",
			"return pow(max(f, 0.0), e);",
		"}",

		"float rayleighPhase(float cosTheta)",
		"{",
			"return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));",
		"}",

		"float hgPhase(float cosTheta, float g)",
		"{",
			"return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / powClamp(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));",
		"}",

		// Filmic ToneMapping http://filmicgames.com/archives/75
		"const float A = 0.15;",
		"const float B = 0.50;",
		"const float C = 0.10;",
		"const float D = 0.20;",
		"const float E = 0.02;",
		"const float F = 0.30;",

		"const float whiteScale = 1.0748724675633854;", // 1.0 / Uncharted2Tonemap(1000.0)

		"vec3 Uncharted2Tonemap(vec3 x)",
		"{",
		   "return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;",
		"}",

`float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

float noise(vec3 p){
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);

    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = perm(b.xyxy);
    vec4 k2 = perm(k1.xyxy + b.zzww);

    vec4 c = k2 + a.zzzz;
    vec4 k3 = perm(c);
    vec4 k4 = perm(c + 1.0);

    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));

    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

    return o4.y * d.y + o4.x * (1.0 - d.y);
}`,


		"void main() ",
		"{",
			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			"float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));",
			"float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * powClamp(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",
			"float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * powClamp(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",

			// combined extinction factor
			"vec3 Fex = exp(-(vBetaR * sR + vBetaM * sM));",

			// in scattering
			"float cosTheta = dot(normalize(vWorldPosition - cameraPos), vSunDirection);",

			"float rPhase = rayleighPhase(cosTheta*0.5+0.5);",
			"vec3 betaRTheta = vBetaR * rPhase;",

			"float mPhase = hgPhase(cosTheta, mieDirectionalG);",
			"vec3 betaMTheta = vBetaM * mPhase;",

			"vec3 Lin = powClamp(vSunE * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * (1.0 - Fex),vec3(1.5));",
			"Lin *= mix(vec3(1.0),pow(vSunE * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, vSunDirection),5.0),0.0,1.0));",

			//nightsky
			"vec3 direction = normalize(vWorldPosition - cameraPos);",
			"float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]",
			"float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]",
			"vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);",
			"vec3 L0 = vec3(0.1) * Fex;",

			// composition + solar disc
			"float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);",
			"L0 += (vSunE * 19000.0 * Fex)*sundisk;",

			"float cosTheta2 = dot(normalize(vWorldPosition - cameraPos), vec3(-vSunDirection.x, -vSunDirection.y, vSunDirection.z));",
			"float moonDisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta2);",
			"L0 += vec3(50.0)*moonDisk;",

			"vec3 starsColor = vec3(0.0);",
      `if (noise(floor(vWorldPosition / 0.1) * 0.1) < 0.0001) {`,
      `  starsColor += (0.15 / 0.04) * max(1.0 - (vSunE / 300.0), 0.0);`,
      `}`,
			"vec3 texColor = (Lin + L0 + starsColor) * 0.04 + (vec3(0.0, 0.0003, 0.00075) * 10.0);",

			"vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);",
			"vec3 color = curr*whiteScale;",

			// "vec3 retColor = powClamp(color,vec3(1.0/(1.2+(1.2*vSunfade))));",

			"gl_FragColor.rgb = L0;",

			"gl_FragColor.a = 1.0;",
		"}",

	].join( "\n" )

};

function THREESky() {
	var skyUniforms = THREE.UniformsUtils.clone(skyShader.uniforms);

  skyUniforms.turbidity.value = 10;
  skyUniforms.rayleigh.value = 2;
  skyUniforms.luminance.value = 1;
  skyUniforms.mieCoefficient.value = 0.005;
  skyUniforms.mieDirectionalG.value = 0.8;

  // sky.inclination = 0;
  // sky.azimuth = 0;

	var skyMat = new THREE.ShaderMaterial( {
		fragmentShader: skyShader.fragmentShader,
		vertexShader: skyShader.vertexShader,
		uniforms: skyUniforms,
		side: THREE.DoubleSide,
	} );

	var skyGeo = new THREE.SphereBufferGeometry( 500, 5, 3 );
	var skyMesh = new THREE.Mesh( skyGeo, skyMat );

  const sunDistance = 5000;
  const cutoffAngle = Math.PI/1.95;
  const steepness = 1.5;
  const computeSunIntensity = zenithAngleCos => {
    zenithAngleCos = Math.min(Math.max(zenithAngleCos, -1), 1);
    return Math.max(0, 1 - Math.pow(Math.E, -((cutoffAngle - Math.acos(zenithAngleCos))/steepness)));
  };
  const maxSunIntensity = computeSunIntensity(1);
  // let lastLightmapUpdateTime = 0;
  const _update = () => {
    const now = Date.now();
    const speed = 100;
    skyMesh.azimuth = (0.05 + (((now + 200000) / 1000) * speed / 100000)) % 1;
    const theta = Math.PI * (skyMesh.inclination - 0.5);
    const phi = 2 * Math.PI * (skyMesh.azimuth - 0.5);

    const x = sunDistance * Math.cos(phi);
    const y = sunDistance * Math.sin(phi) * Math.sin(theta);
    const z = sunDistance * Math.sin(phi) * Math.cos(theta);

    skyMesh.material.uniforms.sunPosition.value.set(x, y, z);
  };
  _update();

  return skyMesh;
}
const sphereMesh = THREESky();
scene.add(sphereMesh); */

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.6;
// camera.position.z = 1;

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
renderer.domElement.id = 'canvas';
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const layers = [renderer.domElement];

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight2.position.set(-1, 1, -1);
scene.add(directionalLight2);

{
  const loader = new THREE.GLTFLoader(); // .setPath( 'models/' );
  const material = new THREE.MeshPhongMaterial({
    color: 0x808080,
    vertexColors: THREE.VertexColors,
  });
  loader.load('buildings.glb', function (o) {
    const heightOffset = -79;

    console.log(o.scene);
    const buildings = [];
    for (let i = 2; i < o.scene.children.length; i++) {
      const child = o.scene.children[i];
      if (child.isMesh) {
        // child.material = material;
        // child.material = child.material.slice(0, 1);
        child.position.y += -79;
        for (let j = 2; j < child.material.length; j++) {
          // child.material.flatShading = true;
          // child.material[j].color.offsetHSL(0, 100, 0);
          /* child.material[j].color.r += 0.1;
          child.material[j].color.g += 0.1;
          child.material[j].color.b += 0.1; */
        }
        buildings.push(child);
      }
    }
    scene.add(buildings[4].clone());
    const numBuildings = 200;
    const buildingRange = 500;
    for (let i = 0; i < numBuildings; i++) {
      const building = buildings[Math.floor(buildings.length * Math.random())].clone();
      building.position.x = (-0.5 + Math.random()) * buildingRange;
      building.position.z = (-0.5 + Math.random()) * buildingRange;
      building.frustumCulled = false;
      scene.add(building);
    }
    const floorMesh = (() => {
      const size = 1;
      const geometry = new THREE.PlaneBufferGeometry(buildingRange, buildingRange)
        .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2))
        .applyMatrix(new THREE.Matrix4().makeTranslation(0, heightOffset, 0));
      const material = new THREE.MeshBasicMaterial({
        color: 0x101010,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      return mesh;
    })();
    scene.add(floorMesh);
  });
}

const toolMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(0.4, 0.1)
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1/2, 0));
  const toolVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const toolFsh = `
    varying vec2 vUv;
    void main() {
      if ((vUv.x < 0.05 || vUv.x > 0.95) || ((vUv.y < 0.05 || vUv.y > 0.95) && (vUv.x < 0.1 || vUv.x > 0.9))) {
        gl_FragColor = vec4(vec3(0.11055276381909548, 0.27638190954773867, 0.4103852596314908) * 2.0, 1.0);
      } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.3);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: toolVsh,
    fragmentShader: toolFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.tool = '';
  mesh.setTool = tool => {
    switch (tool) {
      case 1: {
        mesh.tool = 'point';
        textMesh.geometry.update('Point');
        break;
      }
      case 2: {
        mesh.tool = 'browser';
        textMesh.geometry.update('Browser');
        break;
      }
      case 3: {
        mesh.tool = 'portal';
        textMesh.geometry.update('Portal');
        break;
      }
      case 4: {
        mesh.tool = 'volume';
        textMesh.geometry.update('Volume');
        break;
      }
      default: {
        mesh.tool = -1;
        textMesh.geometry.update('');
        break;
      }
    }
  };
  const textMesh = _makeTextMesh('Point');
  textMesh.position.x += -0.13;
  textMesh.position.y += -0.01;
  textMesh.position.z += 0.001;
  mesh.add(textMesh);
  return mesh;
})();
scene.add(toolMesh);
toolMesh.setTool(1);

// events

let unbindEvents = null;
const _bindEventTarget = target => {
  if (unbindEvents) {
    unbindEvents();
    unbindEvents = null;
  }

  const _bindEvents = (windowEvents = {}, documentEvents = {}) => {
    for (const k in windowEvents) {
      const fn = windowEvents[k];
      window.addEventListener(k, fn);
    }
    for (const k in documentEvents) {
      const fn = documentEvents[k];
      document.addEventListener(k, fn);
    }

    unbindEvents = () => {
      for (const k in windowEvents) {
        const fn = windowEvents[k];
        window.removeEventListener(k, fn);
      }
      for (const k in documentEvents) {
        const fn = documentEvents[k];
        document.removeEventListener(k, fn);
      }
    };
  };
  if (target === 'ui') {
    const _addOrbitControls = () => {
      const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
      orbitControls = new THREE.OrbitControls(orbitCamera);
      orbitCamera.position.copy(fakeXrDisplay.position);
      orbitCamera.quaternion.copy(fakeXrDisplay.quaternion);
      scene.add(orbitCamera);
      orbitCamera.updateMatrixWorld();
      orbitControls.target.copy(orbitCamera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(orbitCamera.quaternion));
      orbitControls.screenSpacePanning = true;
      orbitControls.update();
    };
    const _removeOrbitControls = () => {
      scene.remove(orbitControls.object);
      orbitControls.dispose();
      orbitControls = null;
    };
    /* const _addTransformControls = (camera, iframe) => {
      transformControls = new THREE.TransformControls(camera, document.body, viewport);
      transformControls.iframe = iframe;

      transformControls.addEventListener('dragging-changed', e => {
        orbitControls.enabled = !e.value;
      });
      transformControls.addEventListener('change', e => {
        iframe.position = mesh.position.toArray();
        iframe.orientation = mesh.quaternion.toArray();
        iframe.scale = mesh.scale.toArray();
      });

      const mesh = new THREE.Object3D();
      mesh.position.fromArray(_parseVector(iframe.position));
      mesh.quaternion.fromArray(_parseVector(iframe.orientation));
      mesh.scale.fromArray(_parseVector(iframe.scale));
      scene.add(mesh);
      mesh.updateMatrixWorld();

      transformControls.attach(mesh);
      scene.add(transformControls);
    };
    const _removeTransformControls = () => {
      scene.remove(transformControls.object);
      scene.remove(transformControls);
      transformControls.dispose();
      transformControls = null;
    }; */

    _bindEvents({
      /* mousemove(e) {
        const localCamera = camera;
        localCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
        localCamera.matrixWorld.getInverse(localCamera.matrixWorldInverse);
        localCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
        localCamera.projectionMatrixInverse.getInverse(localCamera.projectionMatrix);

        localCamera.matrixWorld.decompose(localCamera.position, localCamera.quaternion, localCamera.scale);
        const rect = document.body.getBoundingClientRect();
        localRaycaster.setFromCamera(
          localVector2D.set(
            ((e.clientX / rect.width) % 0.5 * 2) * 2 - 1,
            (-e.clientY / rect.height) * 2 + 1
          ),
          localCamera
        );
        const line = localLine.set(
          localRaycaster.ray.origin,
          localVector.copy(localRaycaster.ray.origin)
            .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(100))
        );
        const distanceSpecs = layers.map(layer => {
          if (layer.tagName === 'IFRAME') {
            line.closestPointToPoint(localVector.fromArray(_parseVector(layer.position)), true, localVector2);
            const distance = localVector.distanceTo(localVector2);
            if (distance < 1) {
              return {
                iframe: layer,
                distance,
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        }).filter(spec => !!spec).sort((a, b) => a.distance - b.distance);
        const closestIframe = distanceSpecs.length > 0 ? distanceSpecs[0].iframe : null;
        const shouldTransform = (!!transformControls && transformControls.dragging) || !!closestIframe;
        if (shouldTransform && (!transformControls || (transformControls.iframe !== closestIframe && !transformControls.dragging))) {
          if (transformControls) {
            _removeTransformControls();
          }

          _addTransformControls(localCamera, closestIframe);
        } else if (!shouldTransform && transformControls) {
          _removeTransformControls();
        }
      }, */
      /* keydown(e) {
        if (!window.document.pointerLockElement) {
          switch (e.which) {
            case 27: { // esc
              renderer.domElement.requestPointerLock();
              break;
            }
          }
        }
      }, */
      dblclick(e) {
        if (!window.document.pointerLockElement) {
          renderer.domElement.requestPointerLock();
        }
      },
      keypress(e) {
        // XXX
      },
    }, {
      pointerlockchange(e) {
        if (window.document.pointerLockElement) {
          _bindEventTarget('xr');
        }
      },
    });

    _addOrbitControls();
    unbindEvents = (unbindEvents => function() {
      unbindEvents.apply(this, arguments);
      _removeOrbitControls();
    })(unbindEvents);
  } else if (target === 'xr') {
    for (let i = 0; i < 2; i++) {
      controllerMeshes[i].rayMesh.visible = true;
    }
    _bindEvents({
      /* click(e) {
        renderer.domElement.requestPointerLock();
      }, */
      mousedown(e) {
        if (window.document.pointerLockElement) {
          const gamepads = navigator.getGamepads();
          if (gamepads[1]) {
            gamepads[1].buttons[1].pressed = true;
          }
        }
      },
      mouseup(e) {
        if (window.document.pointerLockElement) {
          const gamepads = navigator.getGamepads();
          if (gamepads[1]) {
            gamepads[1].buttons[1].pressed = false;
          }
        }
      },
      mousemove(e) {
        if (window.document.pointerLockElement) {
          const {movementX, movementY} = e;

          /* if (keys.ctrl) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.y -= movementY * 0.002;
          } else if (keys.alt) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.z += movementY * 0.002;
          } else { */
            localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
            localEuler.y -= movementX * 0.01;
            localEuler.x -= movementY * 0.01;
            localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
            fakeXrDisplay.quaternion.setFromEuler(localEuler);

            fakeXrDisplay.pushUpdate();
          // }
        }
      },
      wheel(e) {
        if (window.document.pointerLockElement) {
          rig.menuMesh.listMesh.updateWheel(e.deltaX/100, -e.deltaY/100);
        }
      },
      keydown(e) {
        if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 83: { // S
              keys.down = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 65: { // A
              keys.left = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 68: { // D
              keys.right = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = true;
              }
              break;
            }
            case 32: { // space
              keys.space = true;
              break;
            }
            case 17: { // ctrl
              keys.ctrl = true;
              break;
            }
            case 49: // 1
            case 50: // 2
            case 51: // 3
            case 52: // 4
            {
              toolMesh.setTool(e.which - 48);
              break;
            }
          }
        } else {
          if (focusedTab) {
            if (focusedTab === rig.menuMesh.urlMesh) {
              rig.menuMesh.urlMesh.handleKey(e.keyCode, e.shiftKey);
            } else if (focusedTab.iframe) {
              focusedTab.iframe.sendKeyDown(e.which, {
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
              });
            }
          }
        }
      },
      keyup(e) {
        if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = false;
              break;
            }
            case 83: { // S
              keys.down = false;
              break;
            }
            case 65: { // A
              keys.left = false;
              break;
            }
            case 68: { // D
              keys.right = false;
              break;
            }
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = false;
              }
              break;
            }
            case 32: { // space
              keys.space = false;
              break;
            }
            case 17: { // ctrl
              keys.ctrl = false;
              break;
            }
          }
        } else {
          if (focusedTab && focusedTab.iframe) {
            focusedTab.iframe.sendKeyUp(e.which, {
              shiftKey: e.shiftKey,
              ctrlKey: e.ctrlKey,
              altKey: e.altKey,
            });
          }
        }
      },
      keypress(e) {
        if (!window.document.pointerLockElement) {
          if (focusedTab) {
            /* if (focusedTab === rig.menuMesh.urlMesh) {
              rig.menuMesh.urlMesh.handleKey(e.keyCode, e.shiftKey);
            } else */if (focusedTab.iframe) {
              focusedTab.iframe.sendKeyPress(e.which, {
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
              });
            }
          }
        }
      },
    }, {
      pointerlockchange(e) {
        if (!window.document.pointerLockElement) {
          _bindEventTarget('ui');
        }
      },
    });
  }
};

// mutation observer

const observer = new MutationObserver(records => {
  for (let i = 0; i < records.length; i++) {
    const record = records[i];
    const {removedNodes} = record;

    for (let j = 0; j < removedNodes.length; j++) {
      const node = removedNodes[j];

      if (node.tagName === 'IFRAME') {
        const iframe = node;

        if (iframe.destroy) {
          iframe.destroy();
        }

        const tabIndex = tabs.findIndex(tab => tab.iframe === iframe);
        if (tabIndex !== -1) {
          const tab = tabs.splice(tabIndex, 1)[0];
          const {id} = tab;

          if (serverConnectedUrl) {
            const objectMesh = xrmp.getObjectMeshes().find(objectMesh => objectMesh.object.id === id);
            xrmp.removeObjectMesh(objectMesh);
          }
        }
        const layerIndex = layers.indexOf(iframe);
        if (layerIndex !== -1) {
          layers.splice(layerIndex, 1);
        }
      }
    }
  }
});
observer.observe(document.body, {
  childList: true,
});

// controller meshes

const controllerGeometry = new THREE.BoxBufferGeometry(0.05, 0.1, 0.01);
const controllerMaterial = new THREE.MeshPhongMaterial({
  color: 0x4caf50,
});
const controllerMeshes = Array(2);
for (let i = 0; i < controllerMeshes.length; i++) {
  const controllerMesh = new THREE.Object3D();
  controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 0, -0.1);
  controllerMesh.quaternion.setFromUnitVectors(
    new THREE.Vector3(0, 0, -1),
    new THREE.Vector3(0, -1, -1)
  );

  const rayMesh = (() => {
    const geometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
      .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
    const material = new THREE.MeshBasicMaterial({
      color: RAY_COLOR,
    });

    const mesh = new THREE.Mesh(geometry, material);
    // mesh.visible = true;
    mesh.frustumCulled = false;
    return mesh;
  })();
  controllerMesh.add(rayMesh);
  controllerMesh.rayMesh = rayMesh;

  const dotMesh = (() => {
    const geometry = new THREE.SphereBufferGeometry(0.01, 5, 5);
    const material = new THREE.MeshBasicMaterial({
      color: 0xe91e63,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = -1;
    mesh.visible = true;
    return mesh;
  })();
  controllerMesh.add(dotMesh);
  controllerMesh.dotMesh = dotMesh;

  controllerMesh.ray = new THREE.Ray();
  controllerMesh.update = () => {
    controllerMesh.ray.origin.copy(controllerMesh.position);
    controllerMesh.ray.direction
      .set(0, 0, -1)
      .applyQuaternion(controllerMesh.quaternion);
  };

  scene.add(controllerMesh);
  controllerMeshes[i] = controllerMesh;
}
controllerMeshes[1].add(toolMesh);
const _getControllerIndex = gamepad => gamepad.hand === 'left' ? 0 : 1;

// grid

const gridMesh = (() => {
  const topGeometry = new THREE.BoxBufferGeometry(0.01, 1, 0.01);
  const leftGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0))
  ));
  const frontGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))
  ));
  const boxGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, 0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, 0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, -0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, -0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, -0.5)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
  ]);
  const boxGeometries = [];
  for (let x = -8; x <= 8; x++) {
    for (let y = 0; y <= 4; y++) {
      for (let z = -8; z <= 8; z++) {
        boxGeometries.push(boxGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z)));
      }
    }
  }
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(boxGeometries);
  const gridVsh = `
    varying vec3 vWorldPos;
    // varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vUv = uv;
      vWorldPos = abs(position);
    }
  `;
  const gridFsh = `
    // uniform sampler2D uTex;
    uniform float uTime;
    varying vec3 vWorldPos;
    void main() {
      /* float distance = sqrt(vWorldPos.x*vWorldPos.x + vWorldPos.y*vWorldPos.y + vWorldPos.z*vWorldPos.z);
      float distance2 = uTime - 3.0;
      float d = abs(distance - distance2); */

      float distance2 = uTime - 3.0;
      float d;
      if (vWorldPos.x >= vWorldPos.y && vWorldPos.x >= vWorldPos.z) {
        d = abs(vWorldPos.x - distance2);
      } else if (vWorldPos.y >= vWorldPos.x && vWorldPos.y >= vWorldPos.z) {
        d = abs(vWorldPos.y - distance2);
      } else {
        d = abs(vWorldPos.z - distance2);
      }

      gl_FragColor = vec4(0.11055276381909548, 0.27638190954773867, 0.4103852596314908, 1.0) * (4.0 - pow(d, 3.0)) * 0.5; // 0x42a5f5
      // gl_FragColor = max(gl_FragCoor, vec4(0.2));
      if (gl_FragColor.a >= 1.9) {
        gl_FragColor.rgb *= 3.0;
      } else if (gl_FragColor.a <= 0.1) {
        discard;
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: gridVsh,
    fragmentShader: gridFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(gridMesh);

const menuMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(2, 1);
  const texture = new THREE.Texture(
    null,
    THREE.UVMapping,
    THREE.ClampToEdgeWrapping,
    THREE.ClampToEdgeWrapping,
    THREE.LinearFilter,
    THREE.LinearFilter,
    THREE.RGBAFormat,
    THREE.UnsignedByteType,
    16
  );
  const material = new THREE.MeshBasicMaterial({
    map: texture,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.plane = new THREE.Plane();
  mesh.leftLine = new THREE.Line3();
  mesh.topLine = new THREE.Line3();
  mesh.update = () => {
    const menuWorldWidth = 2;
    const menuWorldHeight = 1;
    mesh.leftLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.leftLine.end
      .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.topLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.topLine.end
      .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.plane.setFromCoplanarPoints(
      mesh.leftLine.start,
      mesh.leftLine.end,
      mesh.topLine.end
    );
  };
  return mesh;
})();
scene.add(menuMesh);
let menuIframe = null;
const _initMenu = () => {
  menuIframe = document.createElement('iframe');
  menuIframe.onload = () => {
    const properties = renderer.properties.get(menuMesh.material.map);
    properties.__webglTexture = menuIframe.texture;
    properties.__webglInit = true;

    menuIframe.contentWindow.onmessage = m => {
      switch (m.data.method) {
        case 'openTab': {
          const {url} = m.data;

          const location = targetMesh.material.uniforms.worldPos.value;

          const room = _makeRoomMesh(location.x, location.y, location.z, location.x, location.y, location.z, 0x9ccc65);
          scene.add(room);
          rooms.push(room);

          const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, room);
          scene.add(roomLinkMesh);
          roomLinks.push(roomLinkMesh);

          const roomDiagramMesh = _makeRoomDiagramMesh(roomDiagrams.length, room.classify(), 'tutorial.html', 0xffee58);
          scene.add(roomDiagramMesh);
          roomDiagrams.push(roomDiagramMesh);

          _addVolume(room);

          menuIframe.contentWindow.postMessage({
            method: 'tabs',
            tabs: roomDiagrams.map(roomDiagram => roomDiagram.label),
          });

          break;
        }
        case 'closeTab': {
          const {index} = m.data;
          scene.remove(rooms.splice(index, 1)[0]);
          scene.remove(roomLinks.splice(index, 1)[0]);
          scene.remove(roomDiagrams.splice(index, 1)[0]);

          menuIframe.contentWindow.postMessage({
            method: 'tabs',
            tabs: roomDiagrams.map(roomDiagram => roomDiagram.label),
          });

          break;
        }
      }
    };
    menuIframe.contentWindow.postMessage({
      method: 'tabs',
      tabs: roomDiagrams.map(roomDiagram => roomDiagram.label),
    });
  };
  menuIframe.width = 2048;
  menuIframe.height = 1024;
  menuIframe.d = 2;
  menuIframe.src = 'menu/build/index.html';
  document.body.appendChild(menuIframe);
};

const trayMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(2, 0.3)
    .applyMatrix(localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), -Math.PI/2)));
  const material = new THREE.MeshBasicMaterial({
    color: 0x333333,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(trayMesh);

const _makeRoomMesh = (sx, sy, sz, dx, dy, dz, color) => {
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  /* const uvs = geometry.attributes.uv.array;
  const baseUvs = Float32Array.from(uvs);
  const _updateUvs = () => {
    for (let i = 0; i < uvs.length; i += 2) {
      uvs[i] = baseUvs[i] * s;
      uvs[i+1] = baseUvs[i+1] * s;
    }
    geometry.attributes.uv.needsUpdate = true;
  };
  _updateUvs(); */
  const roomVsh = `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vNormal = normal;
      // vWorldPos = abs(position);
    }
  `;
  const roomFsh = `
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      // vec2 uv = fract(vUv);
      vec2 uv;
      if (vNormal.x != 0.0) {
        uv = fract(vWorldPos.yz + vec2(0.0, 0.5));
      } else if (vNormal.y != 0.0) {
        uv = fract(vWorldPos.xz + 0.5);
      } else /* if (vNormal.z != 0.0) */ {
        uv = fract(vWorldPos.xy + vec2(0.5, 0.0));
      }
      /* float diff = uv.x;
      diff = min(diff, abs(uv.x - 1.0));
      diff = min(diff, uv.y);
      diff = min(diff, abs(uv.y - 1.0));
      if (diff <= 0.01) { */
      if ((uv.x <= 0.01 || uv.x >= 0.99) || (uv.y <= 0.01 || uv.y >= 0.99)) {
        // gl_FragColor = vec4(uColor * (1.0 - min(diff/0.02, 1.0)), 0.5);
        gl_FragColor = vec4(uColor, 0.5);
      // } else if (abs(abs(uv.x - 0.5) - abs(uv.y - 0.5)) <= 0.01) {
      } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5);
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.5);
      }

      gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uHighlight: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    mesh.position.set((sx + dx)/2, (sy + dy)/2 + 0.5, (sz + dz)/2);
    mesh.scale.set(Math.abs(dx - sx) + 1, Math.abs(dy - sy) + 1, Math.abs(dz - sz) + 1);
    mesh.updateMatrixWorld();
  };
  mesh.update();
  mesh.getRange = () => [sx, sy, sz, dx, dy, dz];
  mesh.classify = () => {
    const wx = Math.abs(dx - sx) + 1;
    const wy = Math.abs(dy - sy) + 1;
    const wz = Math.abs(dz - sz) + 1;
    if (wx === 1 && wy === 1 && wz === 1) {
      return 'point';
    } else if (wx === 1 && wy === 2 && wz === 1) {
      return 'portal';
    } else {
      const sortedDimensions = [wx, wy, wz].sort((a, b) => a - b);
      if (sortedDimensions[0] === 1 && sortedDimensions[1] > 1 && sortedDimensions[2] > 1) {
        return 'plane';
      } else {
        return 'volume';
      }
    }
  };
  mesh.setEnd = (newDx, newDy, newDz) => {
    dx = newDx;
    dy = newDy;
    dz = newDz;

    mesh.update();
  };
  mesh.setColor = c => {
    mesh.material.uniforms.uColor.value.setHex(c);
  };
  mesh.setHighlight = highlight => {
    mesh.material.uniforms.uHighlight.value = highlight ? 0.2 : 0;
  };
  mesh.contains = position => {
    const box = new THREE.Box3();
    box.expandByPoint(new THREE.Vector3(sx, sy, sz));
    box.expandByPoint(new THREE.Vector3(dx, dy, dz));
    return box.containsPoint(position);
  };
  return mesh;
};
const _makeBrowserMesh = (sx, sy, sz, ox, oy, oz, ow, color) => {
  let dx = sx;
  let dy = sy;
  let dz = sz;

  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const browserVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const browserFsh = `
    varying vec2 vUv;
    void main() {
      if ((vUv.x < 0.01 || vUv.x > 0.99) || (vUv.y < 0.01 || vUv.y > 0.99)) {
        gl_FragColor = vec4(1.0, 0.792156862745098, 0.1568627450980392, 1.0);
      } else {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.2);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: browserVsh,
    fragmentShader: browserFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  const startPoint = new THREE.Vector3(sx, sy, sz);
  const quaternion = new THREE.Quaternion(ox, oy, oz, ow);
  const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion), startPoint);
  mesh.update = () => {
    const endPoint = new THREE.Vector3(dx, dy, dz);
    const upLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion)));
    const rightLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion)));

    endPoint.add(plane.normal.clone().multiplyScalar(-plane.distanceToPoint(endPoint)));
    const midPoint = startPoint.clone().add(endPoint).divideScalar(2);

    const x = rightLine.closestPointToPointParameter(endPoint, false);
    const y = upLine.closestPointToPointParameter(endPoint, false);
    if (x >= -10 && x <= 10 && y >= -10 && y <= 10) {
      mesh.position.copy(midPoint);
      mesh.quaternion.copy(quaternion);
      mesh.scale.set(x, y, 1);
      mesh.updateMatrixWorld();
    }
  };
  mesh.update();
  mesh.setEnd = (newSx, newSy, newSz, newOx, newOy, newOz, newOw) => {
    localRay.set(new THREE.Vector3(newSx, newSy, newSz), new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion(newOx, newOy, newOz, newOw)));
    const intersection = localRay.intersectPlane(plane, new THREE.Vector3());
    if (intersection) {
      dx = intersection.x;
      dy = intersection.y;
      dz = intersection.z;

      mesh.update();
    }
  };
  return mesh;
};
const _makeLabelMesh = s => {
  const geometry = new THREE.PlaneBufferGeometry(1, 0.1)
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1/2, 0));
  const labelVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const labelFsh = `
    varying vec2 vUv;
    void main() {
      if ((vUv.x < 0.01 || vUv.x > 0.99) || ((vUv.y < 0.05 || vUv.y > 0.95) && (vUv.x < 0.02 || vUv.x > 0.98))) {
        gl_FragColor = vec4(vec3(0.11055276381909548, 0.27638190954773867, 0.4103852596314908) * 2.0, 1.0);
      } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.3);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: labelVsh,
    fragmentShader: labelFsh,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane();
  mesh.leftLine = new THREE.Line3();
  mesh.topLine = new THREE.Line3();
  mesh.update = () => {
    const menuWorldWidth = 1;
    const menuWorldHeight = 0.1;
    mesh.leftLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.leftLine.end
      .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.topLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.topLine.end
      .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.plane.setFromCoplanarPoints(
      mesh.leftLine.start,
      mesh.leftLine.end,
      mesh.topLine.end
    );
  };
  const textMesh = _makeTextMesh(s);
  textMesh.position.x += -0.45;
  textMesh.position.y += -0.03;
  textMesh.position.z += 0.001;
  mesh.add(textMesh);
  return mesh;
};
const _makeRoomLinkMesh = (index, roomMesh) => {
  const geometry = new THREE.BoxBufferGeometry(0.005, 0.005, 1);
  const positions = geometry.attributes.position.array;
  const uvs = geometry.attributes.uv.array;
  for (let i = 0; i < uvs.length; i += 2) {
    uvs[i+1] = positions[i/2*3 + 2] + 0.5;
  }
  const roomLinkVsh = `
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      vUv = uv;
    }
  `;
  const roomLinkFsh = `
    uniform float uTime;
    uniform float uLength;
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      // float d = sqrt(vWorldPos.x*vWorldPos.x + vWorldPos.y*vWorldPos.y + vWorldPos.z*vWorldPos.z);
      // if (mod(d, 0.1) <= 0.05) {
      if (mod(vUv.y * uLength, 0.1) <= 0.05) {
        // gl_FragColor = vec4(0.1607843137254902, 0.7137254901960784, 0.9647058823529412, 1.0); // 29b6f6
        gl_FragColor = vec4(max(vec3(0.1607843137254902, 0.7137254901960784, 0.9647058823529412) * (1.0 - pow(uTime, 0.5)), vec3(0.2)), 1.0);
        // gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
        /* if (gl_FragColor.a <= 0.1) {
          discard;
        } */
      } else {
        discard;
        // gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: {
        type: 'f',
        value: 0,
      },
      uLength: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomLinkVsh,
    fragmentShader: roomLinkFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.update = () => {
    localVector
      .copy(trayMesh.position)
      .add(localVector2.set(-0.8 + index * 0.4, 0.1, 0).applyQuaternion(trayMesh.quaternion));
    const [sx, sy, sz, dx, dy, dz] = roomMesh.getRange();
    localVector2.set((sx+dx)/2 + 0.5, (sy+dy)/2 + 0.5, (sz+dz)/2 + 0.5);

    mesh.position
      .copy(localVector)
      .add(localVector2)
      .divideScalar(2);
    mesh.quaternion.setFromUnitVectors(localVector3.set(0, 0, -1), localVector4.copy(localVector2).sub(localVector).normalize());
    const d = localVector.distanceTo(localVector2);
    mesh.scale.set(1, 1, d);
    mesh.material.uniforms.uLength.value = d;
    mesh.updateMatrixWorld();

    mesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;
  };
  mesh.update();
  return mesh;
};
const _makeRoomDiagramMesh = (index, type, label, color) => {
  let wx, wy, wz;
  if (type === 'point') {
    wx = 1;
    wy = 1;
    wz = 1;
  } else if (type === 'portal') {
    wx = 1;
    wy = 2;
    wz = 1;
  } else if (type === 'plane') {
    wx = 2;
    wy = 2;
    wz = 1;
  } else /* if (type === 'volume') */ {
    wx = 2;
    wy = 2;
    wz = 2;
  }
  const geometry = new THREE.BoxBufferGeometry(0.1*wx, 0.1*wy, 0.1*wz, wx, wy, wz)
    .applyMatrix(localMatrix.makeTranslation(0.1*wx/2, 0.1*wy/2, 0.1*wz/2));
  /* const uvs = geometry.attributes.uv.array;
  const baseUvs = Float32Array.from(uvs);
  const _updateUvs = () => {
    for (let i = 0; i < uvs.length; i += 2) {
      uvs[i] = baseUvs[i] * s;
      uvs[i+1] = baseUvs[i+1] * s;
    }
    geometry.attributes.uv.needsUpdate = true;
  };
  _updateUvs(); */
  const roomVsh = `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vWorldPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vNormal = normal;
    }
  `;
  const roomFsh = `
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      // vec2 uv = fract(vUv);
      vec2 uv;
      if (vNormal.x != 0.0) {
        uv = fract(vWorldPos.yz/0.1);
      } else if (vNormal.y != 0.0) {
        uv = fract(vWorldPos.xz/0.1);
      } else /* if (vNormal.z != 0.0) */ {
        uv = fract(vWorldPos.xy/0.1);
      }
      if ((uv.x <= 0.01 || uv.x >= 0.99) || (uv.y <= 0.01 || uv.y >= 0.99)) {
        gl_FragColor = vec4(uColor, 0.5);
      } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5);
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.5);
      }

      // gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      /* uHighlight: {
        type: 'f',
        value: 0,
      }, */
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });

  const mesh = new THREE.Object3D();
  mesh.label = label;
  mesh.update = () => {
    mesh.position
      .copy(trayMesh.position)
      .add(localVector.set(-0.8 + index * 0.4, 0.1, 0).applyQuaternion(trayMesh.quaternion));
    mesh.rotation.y += 0.01;
    mesh.updateMatrixWorld();
  };
  mesh.update();

  const innerMesh = new THREE.Mesh(geometry, material);
  innerMesh.position.set(-0.1*wx/2, -0.1*wy/2, -0.1*wz/2);
  innerMesh.frustumCulled = false;
  mesh.add(innerMesh);

  return mesh;
};
const _addVolume = roomMesh => {
  const iframe = document.createElement('iframe');
  document.body.appendChild(iframe);

  const type = roomMesh.classify();
  if (type === 'point') {
    iframe.d = 3;
    iframe.src = 'tutorial.html';

    const [sx, sy, sz, dx, dy, dz] = roomMesh.getRange();
    const position = [(sx+dx)/2, (sy+dy)/2, (sz+dz)/2];
    iframe.position = position;
    iframe.orientation = [0, 0, 0, 1];
    iframe.scale = [1, 1, 1];

    layers.push(iframe);
  } else if (type === 'portal') {
    iframe.d = 3;
    iframe.src = 'tutorial.html';

    // _setPosition();

    const [sx, sy, sz, dx, dy, dz] = roomMesh.getRange();
    const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
    c.matrixWorld.decompose(localVector, localQuaternion, localVector2);
    localVector.set(0, 0, -1).applyQuaternion(localQuaternion);
    const normal = new THREE.Vector3();
    if (Math.abs(localVector.x) >= Math.abs(localVector.z)) {
      if (localVector.x >= 0) {
        normal.set(-1, 0, 0);
      } else {
        normal.set(1, 0, 0);
      }
    } else {
      if (localVector.z >= 0) {
        normal.set(0, 0, -1);
      } else {
        normal.set(0, 0, 1);
      }
    }

    const position = new THREE.Vector3((sx+dx)/2, (sy+dy)/2 + 0.5, (sz+dz)/2);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(localVector.set(0, 0, 1), normal);
    const scale = new THREE.Vector3(1, 2, 1);
    const color = 0x333333;

    iframe.position = [position.x, position.y - 1, position.z];
    iframe.orientation = quaternion.toArray();
    iframe.scale = [1, 1, 1];

    const portalMesh = _makePortalMesh(position, quaternion, scale, iframe, color);
    scene.add(portalMesh);
    portalMeshes.push(portalMesh);
  } else if (type === 'plane') {
    iframe.d = 2;
    iframe.src = 'https://google.com';

    const [sx, sy, sz, dx, dy, dz] = roomMesh.getRange();
    const wx = Math.abs(dx - sx) + 1;
    const wy = Math.abs(dy - sy) + 1;
    const wz = Math.abs(dz - sz) + 1;
    const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
    c.matrixWorld.decompose(localVector, localQuaternion, localVector2);
    localVector.set(0, 0, -1).applyQuaternion(localQuaternion);
    const normal = new THREE.Vector3();
    let scale;
    if (wx === 1) {
      if (localVector.x > 0) {
        normal.set(-1, 0, 0);
      } else {
        normal.set(1, 0, 0);
      }
      scale = [wz, wy, 1];
    } else if (wy === 1) {
      if (localVector.y > 0) {
        normal.set(0, -1, 0);
      } else {
        normal.set(0, 1, 0);
      }
      scale = [wx, wz, 1];
    } else {
      if (localVector.z > 0) {
        normal.set(0, 0, -1);
      } else {
        normal.set(0, 0, 1);
      }
      scale = [wx, wy, 1];
    }

    const position = [(sx+dx)/2 + normal.x/2, (sy+dy)/2 + normal.y/2, (sz+dz)/2 + normal.z/2];
    if (position[1] > 0) {
      position[1] += 0.5;
    }
    iframe.position = position;
    iframe.orientation = localQuaternion.setFromUnitVectors(localVector.set(0, 0, 1), normal).toArray();
    iframe.scale = scale;

    layers.push(iframe);
  } else /* if (type === 'volume') */ {
    iframe.d = 3;
    // iframe.src = 'https://rawcdn.githack.com/exokitxr/webxr-samples/a8e2c94eba0ee5c9215f20d13057b6c25675d9b0/xr-presentation.html';
    iframe.src = 'rain.html';

    // _setPosition();

    const [sx, sy, sz, dx, dy, dz] = roomMesh.getRange();
    iframe.position = [(sx+dx)/2, (sy+dy)/2, (sz+dz)/2];
    iframe.orientation = [0, 0, 0, 1];
    iframe.scale = [1, 1, 1];

    const position = new THREE.Vector3((sx+dx)/2, (sy+dy)/2 + 0.5, (sz+dz)/2);
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3(Math.abs(sx - dx) + 1, Math.abs(sy - dy) + 1, Math.abs(sz - dz) + 1);
    const volumeMesh = _makeVolumeMesh(position, quaternion, scale, iframe);
    scene.add(volumeMesh);
    volumeMeshes.push(volumeMesh);
  }
};

const targetMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
  const targetVsh = `
    uniform vec3 worldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + worldPos, 1.);
    }
  `;
  const targetFsh = `
    uniform float uTime;
    void main() {
      gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      worldPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(targetMesh);

const portalVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const portalFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 pmi;
  uniform mat4 mwi;
  float checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) - uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(pmi[0][0], pmi[1][1]) * clip_space_position.xy,
      -1.0,
      pmi[2][3] * clip_space_position.z + pmi[3][3]);
    return view_position;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    /* vec2 ndc = (texCoordFull * 2.0) - 1.0;
    float z_n = 2.0 * z_b - 1.0;
    float zNear = projectionMatrix[3][2] / (projectionMatrix[2][2] - 1.0);
    float zFar = projectionMatrix[3][2] / (projectionMatrix[2][2] + 1.0);
    float z_e = 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear)); */

    vec4 worldPos = calculate_view_position(texCoordFull, z_b);
    worldPos /= worldPos.w;
    worldPos = mwi * worldPos;

    float p = checkPlane(worldPos, uPlane);
    if (p >= 0.0) {
    // if (worldPos.y >= 0.0) {
      gl_FragColor = texture2D(uTex, texCoord);
      gl_FragDepth = min(gl_FragCoord.z, z_b);
    } else {
      if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z;
    }
    
    gl_FragColor.rgb += vec3(texCoord, 1.0) * 0.2;
  }
`;

const volumeVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const volumeFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane0;
  uniform vec4 uPlane1;
  uniform vec4 uPlane2;
  uniform vec4 uPlane3;
  uniform vec4 uPlane4;
  uniform vec4 uPlane5;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 pmi;
  uniform mat4 mwi;
  bool checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) >= uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(pmi[0][0], pmi[1][1]) * clip_space_position.xy,
      -1.0,
      pmi[2][3] * clip_space_position.z + pmi[3][3]);
    return view_position;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    vec4 worldPos = calculate_view_position(texCoordFull, z_b);
    worldPos /= worldPos.w;
    worldPos = mwi * worldPos;

    vec4 c = texture2D(uTex, texCoord);

    if (
      c.a == 0.0 || (
        checkPlane(worldPos, uPlane0) &&
        checkPlane(worldPos, uPlane1) &&
        checkPlane(worldPos, uPlane2) &&
        checkPlane(worldPos, uPlane3) &&
        checkPlane(worldPos, uPlane4) &&
        checkPlane(worldPos, uPlane5)
      )
    ) {
      gl_FragColor = c;
      gl_FragDepth = z_b;
    } else {
      discard;
      /* if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z; */
    }
  }
`;

const portalGeometry = (() => {
  const g = new THREE.BoxBufferGeometry().toNonIndexed();
  // g.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
  const ps = g.attributes.position.array;
  const uvs = g.attributes.uv.array;
  const ps2 = [];
  // const uvs2 = [];
  for (let i = 0; i < ps.length/9; i++) {
    if (!(ps[i*9+2] >= 0 && ps[i*9+2+3] >= 0 && ps[i*9+2+6] >= 0)) {
      ps2.push.apply(ps2, ps.slice(i*9, (i+1)*9));
      // uvs2.push.apply(uvs2, uvs.slice(i*6, (i+1)*6));
    }
  };
  const ps3 = new Float32Array(ps2.length);
  // const uvs3 = new Float32Array(uvs2.length);
  for (let i = 0; i < ps2.length/9; i++) {
    ps3[i*9] = ps2[i*9];
    ps3[i*9+1] = ps2[i*9+1];
    ps3[i*9+2] = ps2[i*9+2];

    ps3[i*9+3] = ps2[i*9+6];
    ps3[i*9+3+1] = ps2[i*9+6+1];
    ps3[i*9+3+2] = ps2[i*9+6+2];

    ps3[i*9+6] = ps2[i*9+3];
    ps3[i*9+6+1] = ps2[i*9+3+1];
    ps3[i*9+6+2] = ps2[i*9+3+2];
    
    /* uvs3[i*6] = uvs2[i*6];
    uvs3[i*6+1] = uvs2[i*6+1];

    uvs3[i*6+2] = uvs2[i*6+4];
    uvs3[i*6+2+1] = uvs2[i*6+4+1];

    uvs3[i*6+4] = uvs2[i*6+2];
    uvs3[i*6+4+1] = uvs2[i*6+2+1]; */
  };
  const geometry = new THREE.BufferGeometry();    
  geometry.addAttribute('position', new THREE.BufferAttribute(ps3, 3));
  // geometry.addAttribute('uv', new THREE.BufferAttribute(uvs3, 2));
  return geometry;
})();
const doorMeshGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
  new THREE.PlaneBufferGeometry(0.1, 1).applyMatrix(new THREE.Matrix4().makeTranslation(-0.45, 0, 0.5)),
  new THREE.PlaneBufferGeometry(0.1, 1).applyMatrix(new THREE.Matrix4().makeTranslation(0.45, 0, 0.5)),
  new THREE.PlaneBufferGeometry(1, 0.1).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.45, 0.5)),
  new THREE.PlaneBufferGeometry(1, 0.1).applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.45, 0.5)),
  new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(-1, 0, 0))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, 0)),
  new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, 0)),
  new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 1, 0))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0)),
  new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, -1, 0))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0)),
  new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5)),
]);
const _makePortalMesh = (position, quaternion, scale, iframe, color) => {
  const geometry = portalGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTex: {
        type: 't',
        value: null,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
      uViewport: {
        type: 'v2',
        value: new THREE.Vector2(),
      },
      uXTex: {
        type: 't',
        value: null,
      },
      uPlane: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      pmi: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      mwi: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
    },
    vertexShader: portalVsh,
    fragmentShader: portalFsh,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(position);
  mesh.quaternion.copy(quaternion);
  mesh.scale.copy(scale);
  mesh.box = new THREE.Box3().setFromCenterAndSize(mesh.position, mesh.scale);
  const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
    new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion),
    position.clone().multiplyScalar(-1).add(new THREE.Vector3(0, 0, -scale.z/2).applyQuaternion(quaternion))
  );
  mesh.material.uniforms.uPlane.value.set(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
  mesh.numRenders = 0;
  mesh.onBeforeRender = function(renderer, scene, camera, geometry, material, group) {
    material.uniforms.mwi.value = viewMatrices[mesh.numRenders];
    material.uniforms.pmi.value = projectionMatrices[mesh.numRenders];

    mesh.numRenders = (mesh.numRenders + 1) % 2;
  };
  const image = new Image();
  image.src = 'x.png';
  image.onload = () => {
    mesh.material.uniforms.uXTex.value = new THREE.Texture(
      image,
      THREE.UVMapping,
      THREE.RepeatWrapping,
      THREE.RepeatWrapping,
      THREE.LinearFilter,
      THREE.LinearFilter,
      THREE.RGBAFormat,
      THREE.UnsignedByteType,
      16
    );
    mesh.material.uniforms.uXTex.value.needsUpdate = true;
  };
  image.onerror = err => {
    console.warn('fail', err.stack);
  };
  const doorMesh = (() => {
    const geometry = doorMeshGeometry;
    const material = new THREE.MeshPhongMaterial({
      color,
    });
    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
  })();
  mesh.add(doorMesh);
  mesh.iframe = iframe;
  return mesh;
};

const volumeGeometry = (() => {
  const g = new THREE.BoxBufferGeometry(1, 1, 1).toNonIndexed();
  const geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(g.attributes.position.array, 3));
  return geometry;
})();
const _makeVolumeMesh = (position, quaternion, scale, iframe) => {
  const geometry = volumeGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTex: {
        type: 't',
        value: null,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
      uViewport: {
        type: 'v2',
        value: new THREE.Vector2(),
      },
      uXTex: {
        type: 't',
        value: null,
      },
      uPlane0: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane1: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane2: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane3: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane4: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane5: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      pmi: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      mwi: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
    },
    vertexShader: volumeVsh,
    fragmentShader: volumeFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const image = new Image();
  image.src = 'x.png';
  image.onload = () => {
    mesh.material.uniforms.uXTex.value = new THREE.Texture(
      image,
      THREE.UVMapping,
      THREE.RepeatWrapping,
      THREE.RepeatWrapping,
      THREE.LinearFilter,
      THREE.LinearFilter,
      THREE.RGBAFormat,
      THREE.UnsignedByteType,
      16
    );
    mesh.material.uniforms.uXTex.value.needsUpdate = true;
  };
  image.onerror = err => {
    console.warn('fail', err.stack);
  };
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(position);
  mesh.quaternion.copy(quaternion);
  mesh.scale.copy(scale);
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, -scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane0.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, -1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane1.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(-scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane2.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(-1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane3.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, -scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane4.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane5.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  mesh.numRenders = 0;
  mesh.onBeforeRender = function(renderer, scene, camera, geometry, material, group) {
    material.uniforms.mwi.value = viewMatrices[mesh.numRenders];
    material.uniforms.pmi.value = projectionMatrices[mesh.numRenders];
      
    mesh.numRenders = (mesh.numRenders + 1) % 2;
  };
  mesh.iframe = iframe;
  return mesh;
};

// rig

let focusedTab = null;
const _makeRig = () => {
  const rig = new THREE.Object3D();
  rig.scale.set(0, 0, 0);
  rig.visible = false;
  rig.open = false;
  rig.animation = null;

  const menuMesh = (() => {
    const object = new THREE.Object3D();
    object.position.set(0, menuPositionHeight, 0);

    const urlMesh = (() => {
      const canvas = document.createElement('canvas');
      canvas.width = menuWidth;
      canvas.height = menuHeight;
      const ctx = canvas.getContext('2d');

      const geometry = new THREE.PlaneBufferGeometry(menuWorldWidth, menuWorldHeight);
      const texture = new THREE.Texture(
        canvas,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.updateMatrixWorld();
      mesh.frustumCulled = false;

      focusedTab = mesh;

      const text = DEFAULT_URL;
      const urlState = {
        text,
        cursor: text.length,
        measures: [],
      };
      mesh.urlState = urlState;

      const _updateText = () => {
        ctx.fillStyle = '#EEE';
        ctx.fillRect(0, 0, menuWidth*0.8 - 5, menuHeight);

        if (focusedTab === mesh) {
          ctx.fillStyle = '#42a5f5';
          ctx.fillRect(0, menuHeight - 5, menuWidth*0.8 - 5, 5);
        }

        ctx.fillStyle = '#EEE';
        ctx.fillRect(menuWidth*0.8, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillRect(0, menuHeight, menuWidth*0.5, menuHeight);

        ctx.fillStyle = '#000';
        ctx.font = `${fontSize}px ${fontFamily}`;

        ctx.fillText(urlState.text, 10, urlBarHeight - 10*2 - 5);
        ctx.fillText('x', menuWidth*0.88, menuHeight*0.7);

        urlState.measures.length = 0;
        urlState.measures.push(0);
        const {width: barWidth} = ctx.measureText('[');
        for (let i = 1; i <= urlState.text.length; i++) {
          const {width} = ctx.measureText('[' + urlState.text.slice(0, i) + ']');
          urlState.measures.push(width - barWidth*2);
        }

        ctx.fillStyle = '#000';
        ctx.fillRect(10 + urlState.measures[urlState.cursor] - cursorWidth/2, 20, cursorWidth, urlBarHeight - 20*2);

        texture.needsUpdate = true;
      };
      _updateText();
      mesh.updateText = _updateText;

      const _handleDefaultKey = (code, shiftKey) => {
        let c = String.fromCharCode(code);
        if (!shiftKey) {
          c = c.toLowerCase();
        }
        _handleSingleKey(c);
      };
      const _handleSingleKey = c => {
        mesh.urlState.text = mesh.urlState.text.slice(0, mesh.urlState.cursor) + c + mesh.urlState.text.slice(mesh.urlState.cursor);
        mesh.urlState.cursor++;
        mesh.updateText();
      };
      const _handleKey = (code, shiftKey) => {
        if (code === 8) { // backspace
          if (mesh.urlState.cursor > 0) {
            mesh.urlState.text = mesh.urlState.text.slice(0, mesh.urlState.cursor - 1) + mesh.urlState.text.slice(mesh.urlState.cursor);
            mesh.urlState.cursor--;
            mesh.updateText();
          } else {
            if (mesh.urlState.text.length === 0) {
              _closeRig();
            }
          }
        } else if (code === 46) { // delete
          if (mesh.urlState.cursor < mesh.urlState.text.length) {
            mesh.urlState.text = mesh.urlState.text.slice(0, mesh.urlState.cursor) + mesh.urlState.text.slice(mesh.urlState.cursor + 1);
            _updateText();
          }
        } else if (code === 32) { // space
          mesh.urlState.text = mesh.urlState.text.slice(0, mesh.urlState.cursor) + ' ' + mesh.urlState.text.slice(mesh.urlState.cursor);
          mesh.urlState.cursor++;
          _updateText();
        } else if (code === 13) { // enter
          const u = (optionsMesh.d === 3 && urlMesh.urlState.text === DEFAULT_URL) ? 'realitytab.html?color=29b6f6' : urlMesh.urlState.text;
          const {position, quaternion, scale} = _getFrontOfCamera();
          _openUrl(u, position, quaternion, scale, optionsMesh.d);
          _updateRigLists();
        } else if (
          code === 9 || // tab
          code === 16 || // shift
          code === 17 || // ctrl
          code === 18 || // alt
          code === 20 || // capslock
          code === 27 || // esc
          code === 91 // win
        ) {
          // nothing
        } else if (code === 37) { // left
          mesh.urlState.cursor = Math.max(mesh.urlState.cursor - 1, 0);
          _updateText();
        } else if (code === 39) { // right
          mesh.urlState.cursor = Math.min(mesh.urlState.cursor + 1, mesh.urlState.text.length);
          _updateText();
        } else if (code === 38) { // up
          if (focusedTab === urlMesh) {
            // nothing
          } else {
            let tabIndex = tabs.indexOf(focusedTab);
            if (tabIndex === 0) {
              focusedTab = urlMesh;
            } else {
              tabIndex--;
              focusedTab = tabs[tabIndex];

              if (tabIndex < listMesh.scrollIndex) {
                listMesh.scrollIndex = tabIndex;
              } else if (tabIndex > listMesh.scrollIndex + 4) {
                listMesh.scrollIndex = tabIndex - 4;
              }
            }
          }
          _updateText();
          listMesh.updateList();
        } else if (code === 40) { // down
          if (focusedTab === urlMesh) {
            if (tabs.length > 0) {
              focusedTab = tabs[0];
              listMesh.scrollIndex = 0;
            } else {
              // nothing
            }
          } else {
            let tabIndex = tabs.indexOf(focusedTab);
            if (tabIndex === tabs.length - 1) {
              // nothing
            } else {
              tabIndex++;
              focusedTab = tabs[tabIndex];

              if (tabIndex < listMesh.scrollIndex) {
                listMesh.scrollIndex = tabIndex;
              } else if (tabIndex > listMesh.scrollIndex + 4) {
                listMesh.scrollIndex = tabIndex - 4;
              }
            }
          }
          _updateText();
          listMesh.updateList();
        } else if (code === 190) { // .
          _handleSingleKey('.');
        } else if (code === 188) { // ,
          _handleSingleKey(',');
        } else if (code === 191) { // /
          _handleSingleKey('/');
        } else if (code === 186) { // ;
          _handleSingleKey(';');
        } else if (code === 222) { // ;
          _handleSingleKey('\'');
        } else if (code === 219) { // [
          _handleSingleKey('[');
        } else if (code === 221) { // ]
          _handleSingleKey(']');
        } else if (code === 189) { // -
          _handleSingleKey('-');
        } else if (code === 187) { // =
          _handleSingleKey('=');
        } else if (code === 220) { // \
          _handleSingleKey('\\');
        } else if (code === -1) {
          // nothing
        } else {
          _handleDefaultKey(code, shiftKey);
        }
      };
      mesh.handleKey = _handleKey;

      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      mesh.update = () => {
        mesh.leftLine.start
          .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.leftLine.end
          .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.topLine.start
          .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };

      return mesh;
    })();
    object.add(urlMesh);
    object.urlMesh = urlMesh;

    const optionsMesh = (() => {
      const canvas = document.createElement('canvas');
      canvas.width = menuWidth;
      canvas.height = menuHeight;
      const ctx = canvas.getContext('2d');

      const geometry = new THREE.PlaneBufferGeometry(menuWorldWidth, menuWorldHeight);
      const texture = new THREE.Texture(
        canvas,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = -menuWorldHeight - (10/menuHeight*menuWorldHeight);
      mesh.updateMatrixWorld();
      mesh.frustumCulled = false;
      mesh.d = 3;
      mesh.list = 'tabs';

      const _updateOptions = () => {
        ctx.font = `${fontSize}px ${fontFamily}`;

        // 3D
        ctx.fillStyle = mesh.d === 3 ? '#42a5f5' : '#EEE';
        ctx.fillRect(0, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillStyle = mesh.d === 3 ? '#FFF' : '#000';
        ctx.fillText('3D', menuWidth*0.2/2 - 30, menuHeight/2 + 20);

        // 2D
        ctx.fillStyle = mesh.d === 2 ? '#42a5f5' : '#EEE';
        ctx.fillRect(menuWidth*0.2, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillStyle = mesh.d === 2 ? '#FFF' : '#000';
        ctx.fillText('2D', menuWidth*0.2 + menuWidth*0.2/2 - 30, menuHeight/2 + 20);

        // Tabs
        ctx.fillStyle = mesh.list === 'tabs' ? '#42a5f5' : '#EEE';
        ctx.fillRect(menuWidth*0.4, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillStyle = mesh.list === 'tabs' ? '#FFF' : '#000';
        ctx.fillText('Tabs', menuWidth*0.4 + menuWidth*0.2/2 - 70, menuHeight/2 + 20);

        // Links
        ctx.fillStyle = mesh.list === 'links' ? '#42a5f5' : '#EEE';
        ctx.fillRect(menuWidth*0.6, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillStyle = mesh.list === 'links' ? '#FFF' : '#000';
        ctx.fillText('Links', menuWidth*0.6 + menuWidth*0.2/2 - 70, menuHeight/2 + 20);

        // Party
        ctx.fillStyle = mesh.list === 'party' ? '#42a5f5' : '#EEE';
        ctx.fillRect(menuWidth*0.8, 0, menuWidth*0.2 - 5, menuHeight);
        ctx.fillStyle = mesh.list === 'party' ? '#FFF' : '#000';
        ctx.fillText('Party', menuWidth*0.8 + menuWidth*0.2/2 - 70, menuHeight/2 + 20);

        texture.needsUpdate = true;
      };
      _updateOptions();
      mesh.updateOptions = _updateOptions;

      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      mesh.update = () => {
        mesh.leftLine.start
          .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.leftLine.end
          .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.topLine.start
          .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };

      return mesh;
    })();
    object.add(optionsMesh);
    object.optionsMesh = optionsMesh;

    const listMesh = (() => {
      const canvas = document.createElement('canvas');
      canvas.width = menuWidth;
      canvas.height = menuHeight*4;
      const ctx = canvas.getContext('2d');

      const geometry = new THREE.PlaneBufferGeometry(menuWorldWidth, menuWorldHeight*4);
      const texture = new THREE.Texture(
        canvas,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = -menuWorldHeight*3.5 - (10/menuHeight*menuWorldHeight)*2;
      mesh.updateMatrixWorld();
      mesh.frustumCulled = false;
      mesh.scrollIndex = 0;
      mesh.scrollIndexFine = 0;

      const _updateList = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.font = `${fontSize}px ${fontFamily}`;

        const _renderScrollbar = listLength => {
          ctx.fillStyle = '#808080';
          ctx.fillRect(menuWidth*0.99, 0, menuWidth*0.01, menuHeight*4);
          const fullBarHeight = menuHeight*4;
          const barHeight = fullBarHeight/Math.min(listLength > 0 ? listLength : 1, 4);
          const barSpace = fullBarHeight - barHeight;
          ctx.fillStyle = '#42a5f5';
          ctx.fillRect(menuWidth*0.99, mesh.scrollIndex*barSpace/(listLength > 1 ? (listLength-1) : 1), menuWidth*0.01, barHeight);
        };

        for (let i = 0; i < iconMeshes.length; i++) {
          const iconMesh = iconMeshes[i];
          if (iconMesh.parent) {
            iconMesh.parent.remove(iconMesh);
          }
        }
        if (optionsMesh.list === 'tabs') {
          if (tabs.length > 0) {
            const localTabs = tabs.slice(mesh.scrollIndex, mesh.scrollIndex + 4);
            for (let i = 0; i < localTabs.length; i++) {
              const tab = localTabs[i];
              const {url} = tab;
              const y = menuHeight*i;

              ctx.fillStyle = tab === focusedTab ? '#2196f3' : '#FFF';
              ctx.fillRect(0, y, menuWidth*0.6 - 5, menuHeight);

              ctx.fillStyle = '#FFF';
              ctx.fillRect(menuWidth*0.6, y, menuWidth*0.1 - 5, menuHeight);
              ctx.fillRect(menuWidth*0.7, y, menuWidth*0.1 - 5, menuHeight);
              ctx.fillRect(menuWidth*0.8, y, menuWidth*0.18, menuHeight);

              ctx.fillStyle = tab === focusedTab ? '#FFF' : '#000';
              ctx.fillText(url, 100, y + menuHeight/2 + 20);

              ctx.fillStyle = '#000';
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(menuWidth*0.65 - 5, y + menuHeight*0.5 - 20);
              ctx.lineTo(menuWidth*0.65 - 5, y + menuHeight*0.5 + 20);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(menuWidth*0.65 - 5 - 20, y + menuHeight*0.5);
              ctx.lineTo(menuWidth*0.65 - 5 + 20, y + menuHeight*0.5);
              ctx.stroke();

              ctx.beginPath();
              ctx.moveTo(menuWidth*0.75 - 5, y + menuHeight*0.5 - 20);
              ctx.lineTo(menuWidth*0.75 - 5 + 20, y + menuHeight*0.5);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(menuWidth*0.75 - 5 + 20, y + menuHeight*0.5);
              ctx.lineTo(menuWidth*0.75 - 5, y + menuHeight*0.5 + 20);
              ctx.stroke();

              ctx.fillText('x', menuWidth*0.88, y + menuHeight*0.7);
            }
          } else {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, menuWidth*0.3 - 5, menuHeight);

            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('No tabs', 50, menuHeight/2 + 20);
          }

          _renderScrollbar(tabs.length);
        } else if (optionsMesh.list === 'links') {
          const localLinks = links.slice(mesh.scrollIndex, mesh.scrollIndex + 4);
          for (let i = 0; i < localLinks.length; i++) {
            const link = localLinks[i];
            const {name} = link;
            const y = menuHeight*i;

            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, y, menuWidth*0.98, menuHeight);

            ctx.fillStyle = '#000000';
            ctx.fillText(name, 100, y + menuHeight/2 + 20);

            if (!link.iconMesh) {
              const iconMesh = (() => {
                const iconMesh = new THREE.Object3D();

                function pad(n, width) {
                  return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
                }

                _requestSpriteMesh(`icons/Food_${pad((4+mesh.scrollIndex+i) + '', 2)}.png`)
                  .then(spriteMesh => {
                    spriteMesh.position.set(-0.45, 0.15 - i*0.1, 0.05);
                    spriteMesh.rotation.order = 'YXZ';
                    spriteMesh.scale.set(0.16, 0.16, 0.16);
                    spriteMesh.frustumCulled = false;
                    iconMesh.add(spriteMesh);
                  });

                return iconMesh;
              })();
              link.iconMesh = iconMesh;
              iconMeshes.push(iconMesh);
            }
            mesh.add(link.iconMesh);
            link.iconMesh.children[0] && (link.iconMesh.children[0].position.y = 0.15 - i*0.1);
          }

          _renderScrollbar(links.length);
        } else if (optionsMesh.list === 'party') {
          if (!serverConnectedUrl) {
            if (!serversLoading) {
              if (servers.length > 0) {
                const localServers = servers.slice(mesh.scrollIndex, mesh.scrollIndex + 4);
                for (let i = 0; i < localServers.length; i++) {
                  const server = localServers[i];
                  const {name} = server;
                  const y = menuHeight*i;

                  ctx.fillStyle = '#FFFFFF';
                  ctx.fillRect(0, y, menuWidth*0.98, menuHeight);

                  ctx.fillStyle = '#000000';
                  ctx.fillText(name, 100, y + menuHeight/2 + 20);

                  if (!server.iconMesh) {
                    const iconMesh = (() => {
                      const iconMesh = new THREE.Object3D();

                      function pad(n, width) {
                        return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
                      }

                      _requestSpriteMesh(`icons/Food_${pad((4+mesh.scrollIndex+i) + '', 2)}.png`)
                        .then(spriteMesh => {
                          spriteMesh.position.set(-0.45, 0.15 - i*0.1, 0.05);
                          spriteMesh.rotation.order = 'YXZ';
                          spriteMesh.scale.set(0.16, 0.16, 0.16);
                          spriteMesh.frustumCulled = false;
                          iconMesh.add(spriteMesh);
                        });

                      return iconMesh;
                    })();
                    server.iconMesh = iconMesh;
                    iconMeshes.push(iconMesh);
                  }
                  mesh.add(server.iconMesh);
                  server.iconMesh.children[0] && (server.iconMesh.children[0].position.y = 0.15 - i*0.1);
                }
              } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, menuWidth*0.99 - 5, menuHeight);

                ctx.fillStyle = '#FFFFFF';
                ctx.fillText('No servers', 50, menuHeight/2 + 20);
              }

              _renderScrollbar(servers.length);
            } else {
              ctx.fillStyle = '#000000';
              ctx.fillRect(0, 0, menuWidth*0.99 - 5, menuHeight);

              ctx.fillStyle = '#FFFFFF';
              ctx.fillText('Loading servers...', 50, menuHeight/2 + 20);

              _renderScrollbar(0);
            }
          } else {
            ctx.fillStyle = '#2196f3';
            ctx.fillRect(0, 0, menuWidth*0.8 - 5, menuHeight);
            ctx.fillStyle = '#FFF';
            ctx.fillRect(menuWidth*0.8, 0, menuWidth*0.18, menuHeight);

            ctx.fillStyle = '#FFF';
            ctx.fillText(serverConnectedUrl, 100, menuHeight/2 + 20);

            ctx.fillStyle = '#000';
            ctx.fillText('x', menuWidth*0.88, menuHeight*0.7);

            _renderScrollbar(0);
          }
        }

        texture.needsUpdate = true;
      };
      _updateList();
      mesh.updateList = _updateList;

      const _updateWheel = (dx, dy) => {
        mesh.scrollIndexFine += dy;
        while (mesh.scrollIndexFine >= 0) {
          mesh.scrollIndexFine--;
          mesh.scrollIndex--;
        }
        while (rig.menuMesh.listMesh.scrollIndexFine <= -1) {
          mesh.scrollIndexFine++;
          mesh.scrollIndex++;
        }
        _updateRigLists();
      };
      mesh.updateWheel = _updateWheel;

      mesh.plane = new THREE.Plane();
      mesh.leftLine = new THREE.Line3();
      mesh.topLine = new THREE.Line3();
      mesh.update = () => {
        mesh.leftLine.start
          .set(-menuWorldWidth/2, menuWorldHeight*4/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.leftLine.end
          .set(-menuWorldWidth/2, -menuWorldHeight*4/2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.topLine.start
          .set(-menuWorldWidth/2, menuWorldHeight*4/2, 0)
          .applyMatrix4(mesh.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth/2, menuWorldHeight*4/2, 0)
          .applyMatrix4(mesh.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      };

      return mesh;
    })();
    object.add(listMesh);
    object.listMesh = listMesh;

    return object;
  })();
  rig.add(menuMesh);
  rig.menuMesh = menuMesh;

  const keyboardMesh = (() => {
    const object = new THREE.Object3D();

    const planeMesh = (() => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = 'keyboard.png';
      img.onload = () => {
        texture.needsUpdate = true;
      };
      img.onerror = err => {
        console.warn(err.stack);
      };

      const geometry = new THREE.PlaneBufferGeometry(1, keyboardHeight / keyboardWidth);
      const texture = new THREE.Texture(
        img,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      mesh.position.y = -0.5;
      mesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 1, 1).normalize()
      );

      const keyMeshes = [];
      for (let i = 0; i < 2; i++) {
        const keyMesh = (() => {
          const geometry = new THREE.PlaneBufferGeometry(1, 1);
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.NearestFilter,
            THREE.NearestFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            1
          );
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.frustumCulled = false;
          return mesh;
        })();
        mesh.add(keyMesh);

        keyMeshes.push(keyMesh);
      }
      mesh.keyMeshes = keyMeshes;

      return mesh;
    })();
    object.add(planeMesh);
    object.planeMesh = planeMesh;

    object.plane = new THREE.Plane();
    object.leftLine = new THREE.Line3();
    object.topLine = new THREE.Line3();
    object.update = () => {
      object.leftLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.leftLine.end
        .set(-1/2, -keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.topLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.topLine.end
        .set(1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.plane.setFromCoplanarPoints(
        object.leftLine.start,
        object.leftLine.end,
        object.topLine.end
      );
    };

    return object;
  })();
  rig.add(keyboardMesh);
  rig.keyboardMesh = keyboardMesh;

  return rig;
};
const rig = _makeRig();
scene.add(rig);

const _openRig = (position, quaternion) => {
  if (!rig.open) {
    rig.position.copy(position);
    rig.quaternion.copy(quaternion);

    rig.open = true;
  } else {
    rig.open = false;
  }

  _animateRig();
};
const _closeRig = () => {
  rig.open = false;

  _animateRig();
};
const _animateRig = () => {
  const startScale = rig.scale.x;
  const endScale = rig.open ? 1 : 0;
  const startTime = Date.now();
  const endTime = startTime + 150;
  rig.animation = {
    update() {
      const now = Date.now();
      const factor = Math.min(Math.max(Math.pow((now - startTime) / (endTime - startTime), 0.2), 0), 1);
      const scaleFactor = startScale*(1-factor) + endScale*factor;

      rig.scale.set(scaleFactor, scaleFactor, scaleFactor);
      rig.visible = rig.scale.x > 0.00001;

      if (factor >= 1) {
        rig.animation = null;
      }
    },
  };
};

const cacheCanvas = document.createElement('canvas');
cacheCanvas.width = 1024;
cacheCanvas.height = 1024;
const cacheCanvasCtx = cacheCanvas.getContext('2d');

// box meshes

const boxMeshes = [
  _makeBoxMesh(),
  _makeBoxMesh(),
];
boxMeshes.forEach(boxMesh => {
  scene.add(boxMesh);
});

const moves = [null, null];
const keys = {
  up: false,
  down: false,
  left: false,
  right: false,
};
const _makeButtons = () => ({
  trigger: false,
  bumper: false,
});
const lastButtons = [
  _makeButtons(),
  _makeButtons(),
];
const intersectionSpecs = [
  null,
  null,
];

// let renderTarget = null;
const startTime = Date.now();
let lastTime = 0;
function animate(time, frame) {
  if (frame) {
    const pose = frame.getViewerPose();
    const {views} = pose;
    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      viewMatrices[i]
        .fromArray(pose.getViewMatrix(view))
        .getInverse(viewMatrices[i]);
      projectionMatrices[i]
        .fromArray(view.projectionMatrix)
        .getInverse(projectionMatrices[i]);
    }
  }

  /* const gl = renderer.getContext();
  gl.clearColor(1, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT|gl.STENCIL_BUFFER_BIT);
  return; */
  const now = Date.now();
  const timeDiff = now - lastTime;
  const startTimeDiff = now - startTime;

  const gamepads = navigator.getGamepads();
  for (let i = 0; i < gamepads.length && i < 2; i++) {
    const gamepad = gamepads[i];
    const moveTab = moves[i];
    const boxMesh = boxMeshes[i];

    if (moveTab) {
      const {iframe} = moveTab;

      const scrollFactor = scrollFactors[i];
      const scaleFactor = scaleFactors[i];

      localVector.fromArray(gamepad.pose.position);
      localQuaternion.fromArray(gamepad.pose.orientation);
      localVector
        .add(
          localVector2.set(0, 0, -scrollFactor)
            .applyQuaternion(localQuaternion)
        );
      localVector2.set(scaleFactor, scaleFactor, scaleFactor);

      iframe.position = localVector.toArray();
      iframe.orientation = localQuaternion.toArray();
      iframe.scale = localVector2.toArray();

      boxMesh.position.copy(localVector);
      boxMesh.quaternion.copy(localQuaternion);
      boxMesh.scale.copy(localVector2);
      // boxMesh.updateMatrixWorld();
      boxMesh.visible = true;

      if (serverConnectedUrl) {
        const objectMesh = xrmp.getObjectMeshes().find(objectMesh => objectMesh.object.id === moveTab.id);
        const {object} = objectMesh;
        const {objectMatrix} = object;
        localVector.toArray(objectMatrix.position);
        localQuaternion.toArray(objectMatrix.quaternion);
        object.pushUpdate();
      }
    } else {
      boxMesh.visible = false;
    }
  }

  const _updateControllerMeshes = () => {
    // if (renderer.vr.enabled) {
      for (let i = 0; i < controllerMeshes.length; i++) {
        controllerMeshes[i].visible = false;
      }

      for (let i = 0; i < gamepads.length && i < 2; i++) {
        const gamepad = gamepads[i];

        if (gamepad.connected) {
          const controllerIndex = _getControllerIndex(gamepad);
          const controllerMesh = controllerMeshes[controllerIndex];
          controllerMesh.position.fromArray(gamepad.pose.position);
          controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
          controllerMesh.updateMatrixWorld(true);
          controllerMesh.visible = true;
        }
      }
    // }
  };
  _updateControllerMeshes();

  /* const _updateIntersections = () => {
    for (let i = 0; i < 2; i++) {
      const controllerMesh = controllerMeshes[i];
      controllerMesh.update();

      const _setIntersectionDefault = () => {
        controllerMesh.rayMesh.scale.z = rayDistance;
        controllerMesh.rayMesh.updateMatrixWorld();

        rig.keyboardMesh.planeMesh.keyMeshes[i].visible = false;

        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          const pressed = gamepad.buttons[1].pressed;
          const lastPressed = lastPresseds[i];
          if (pressed && !lastPressed) {
            moves[i] = null;
          }
        }

        intersectionSpecs[i] = null;
      };

      const intersectionPoints = [];
      const intersectionCbs = [];
      const {keyboardMesh, menuMesh} = rig;
      const {planeMesh} = keyboardMesh;
      const keyMesh = planeMesh.keyMeshes[i];
      keyboardMesh.update();
      menuMesh.urlMesh.update();
      menuMesh.optionsMesh.update();
      menuMesh.listMesh.update();

      // keyboard
      {
        const intersectionPoint = keyboardMesh.visible ? controllerMesh.ray.intersectPlane(keyboardMesh.plane, localVector) : null;
        if (intersectionPoint) {
          const leftIntersectionPoint = keyboardMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

          const topIntersectionPoint = keyboardMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(keyboardMesh.topLine.start) / (1);
          const yFactor = leftIntersectionPoint.distanceTo(keyboardMesh.leftLine.start) / (keyboardHeight / keyboardWidth);
          const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const x = xFactor * keyboardWidth;
            const y = yFactor * keyboardHeight;

            intersectionPoints.push(intersectionPoint.clone());
            intersectionCbs.push(() => {
              controllerMesh.rayMesh.scale.z = distance;
              controllerMesh.updateMatrixWorld();

              for (let j = 0; j < keyMap.length; j++) {
                const [key, kx1, ky1, kx2, ky2] = keyMap[j];
                if (x >= kx1 && x < kx2 && y >= ky1 && y < ky2) {
                  if (keyboardHighlightCanvasCtx) {
                    const width = kx2 - kx1;
                    const height = ky2 - ky1;
                    let imageData = keyboardHighlightCanvasCtx.getImageData(kx1, ky1, width, height);
                    if (key === 'enter') { // special case the enter key; it has a non-rectangular shape
                      cacheCanvasCtx.putImageData(imageData, 0, 0);
                      cacheCanvasCtx.clearRect(0, 0, 80, 140);

                      imageData = cacheCanvasCtx.getImageData(0, 0, imageData.width, imageData.height);
                    }

                    keyMesh.material.map.image = imageData;
                    keyMesh.material.map.needsUpdate = true;

                    keyMesh.position
                      .set(
                        -1/2 + ((width/2 + kx1) / keyboardWidth),
                        (keyboardHeight / keyboardWidth)/2 - ((height/2 + ky1) / keyboardHeight * (keyboardHeight / keyboardWidth)),
                         0.01 * (1)
                      );
                    keyMesh.scale.set(
                      width / keyboardWidth,
                      height / keyboardHeight * (keyboardHeight / keyboardWidth),
                      1
                    );
                    keyMesh.updateMatrixWorld();
                    keyMesh.visible = true;
                  }

                  intersectionSpecs[i] = {
                    type: 'key',
                    data: {
                      key,
                      rig,
                    },
                  };

                  break;
                }
              }
            });
          }
        }
      }

      // menu mesh
      {
        const intersectionPoint = menuMesh.visible ? controllerMesh.ray.intersectPlane(menuMesh.urlMesh.plane, localVector) : null;
        if (intersectionPoint) {
          const leftIntersectionPoint = menuMesh.urlMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

          const topIntersectionPoint = menuMesh.urlMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(menuMesh.urlMesh.topLine.start) / menuWorldWidth;
          const yFactor = leftIntersectionPoint.distanceTo(menuMesh.urlMesh.leftLine.start) / menuWorldHeight;
          const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const x = xFactor * menuWidth;
            const y = yFactor * menuHeight;

            if (y < urlBarOffset) {
              if (x < menuWidth*0.8) {
                intersectionPoints.push(intersectionPoint.clone());
                intersectionCbs.push(() => {
                  controllerMesh.rayMesh.scale.z = distance;
                  controllerMesh.updateMatrixWorld();

                  const gamepads = navigator.getGamepads();
                  const gamepad = gamepads[i];
                  if (gamepad.buttons[1].pressed) {
                    const textX = x - cursorWidth;
                    let closestIndex = -1;
                    let closestDistance = Infinity;
                    for (let i = 0; i < menuMesh.urlMesh.urlState.measures.length; i++) {
                      const urlMeasure = menuMesh.urlMesh.urlState.measures[i];
                      const distance = Math.abs(urlMeasure - textX);
                      if (distance < closestDistance) {
                        closestIndex = i;
                        closestDistance = distance;
                      }
                    }
                    if (closestIndex !== -1) {
                      menuMesh.urlMesh.urlState.cursor = closestIndex;
                    }

                    focusedTab = menuMesh.urlMesh;

                    menuMesh.urlMesh.updateText();
                    menuMesh.listMesh.updateList();
                  }

                  intersectionSpecs[i] = null;
                });
              } else {
                intersectionPoints.push(intersectionPoint.clone());
                intersectionCbs.push(() => {
                  controllerMesh.rayMesh.scale.z = distance;
                  controllerMesh.updateMatrixWorld();

                  const gamepads = navigator.getGamepads();
                  const gamepad = gamepads[i];
                  if (gamepad.buttons[1].pressed) {
                    _closeRig();
                  }

                  intersectionSpecs[i] = null;
                });
              }
            }
          }
        }
      }

      // options mesh
      {
        const intersectionPoint = menuMesh.visible ? controllerMesh.ray.intersectPlane(menuMesh.optionsMesh.plane, localVector) : null;
        if (intersectionPoint) {
          const leftIntersectionPoint = menuMesh.optionsMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

          const topIntersectionPoint = menuMesh.optionsMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(menuMesh.optionsMesh.topLine.start) / menuWorldWidth;
          const yFactor = leftIntersectionPoint.distanceTo(menuMesh.optionsMesh.leftLine.start) / menuWorldHeight;
          const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const x = xFactor * menuWidth;
            const y = yFactor * menuHeight;

            if (y >= 0 && y < urlBarOffset) {
              intersectionPoints.push(intersectionPoint.clone());
              intersectionCbs.push(() => {
                controllerMesh.rayMesh.scale.z = distance;
                controllerMesh.updateMatrixWorld();

                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[i];
                if (gamepad.buttons[1].pressed) {
                  const optionX = Math.floor(x/(menuWidth*0.2));
                  if (optionX === 0) {
                    menuMesh.optionsMesh.d = 3;
                    menuMesh.optionsMesh.updateOptions();
                  } else if (optionX === 1) {
                    menuMesh.optionsMesh.d = 2;
                    menuMesh.optionsMesh.updateOptions();
                  } else if (optionX === 2) {
                    menuMesh.optionsMesh.list = 'tabs';
                    menuMesh.optionsMesh.updateOptions();
                    menuMesh.listMesh.scrollIndex = 0;
                    menuMesh.listMesh.updateList();
                  } else if (optionX === 3) {
                    menuMesh.optionsMesh.list = 'links';
                    menuMesh.optionsMesh.updateOptions();
                    menuMesh.listMesh.scrollIndex = 0;
                    menuMesh.listMesh.updateList();
                  } else if (optionX === 4) {
                    menuMesh.optionsMesh.list = 'party';
                    if (!serversLoading) {
                      XRMultiplayer.requestServers(`${registryUrl}/servers`)
                        .then(result => {
                          servers = result.servers;
                          serversLoading = false;

                          menuMesh.listMesh.updateList();
                        })
                        .catch(err => {
                          console.warn(err.stack);

                          serversLoading = false;

                          menuMesh.listMesh.updateList();
                        });

                      serversLoading = true;
                    }
                    menuMesh.optionsMesh.updateOptions();
                    menuMesh.listMesh.scrollIndex = 0;
                    menuMesh.listMesh.updateList();
                  }
                }

                intersectionSpecs[i] = null;
              });
            }
          }
        }
      }

      // list mesh
      {
        const intersectionPoint = menuMesh.visible ? controllerMesh.ray.intersectPlane(menuMesh.listMesh.plane, localVector) : null;
        if (intersectionPoint) {
          const leftIntersectionPoint = menuMesh.listMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

          const topIntersectionPoint = menuMesh.listMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(menuMesh.listMesh.topLine.start) / menuWorldWidth;
          const yFactor = leftIntersectionPoint.distanceTo(menuMesh.listMesh.leftLine.start) / (menuWorldHeight*4);
          const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const x = xFactor * menuWidth;
            const y = yFactor * menuHeight*4;

            if (x < menuWidth * 0.98) {
              if (menuMesh.optionsMesh.list === 'tabs') {
                const localTabs = tabs.slice(menuMesh.listMesh.scrollIndex, menuMesh.listMesh.scrollIndex + 4);
                for (let j = 0; j < localTabs.length; j++) {
                  if (y >= urlBarOffset*j && y < urlBarOffset*(j+1)) {
                    if (x >= menuWidth*0.8) {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          const tab = tabs[menuMesh.listMesh.scrollIndex + j];
                          _closeTab(tab);

                          if (focusedTab === tab) {
                            focusedTab = rig.menuMesh.urlMesh;
                          }

                          rig.menuMesh.urlMesh.updateText();
                          _updateRigLists();
                        }

                        intersectionSpecs[i] = null;
                      });
                    } else if (x >= menuWidth*0.7) {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          const tab = tabs[menuMesh.listMesh.scrollIndex + j];
                          const {iframe} = tab;
                          if (iframe.d === 3) {
                            window.browser.devTools.requestDevTools(iframe.contentWindow, document)
                              .then(devTools => {
                                const {position, quaternion, scale} = _getFrontOfCamera();
                                // position.add(localVector.set(0, -0.3, 0).applyQuaternion(quaternion));
                                _addTab(devTools.getIframe(), position, quaternion, scale, 2);
                              })
                              .catch(err => {
                                console.warn(err.stack);
                              });
                          }
                        }

                        intersectionSpecs[i] = null;
                      });
                    } else if (x >= menuWidth*0.6) {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          const tab = tabs[menuMesh.listMesh.scrollIndex + j];
                          moves[i] = tab;

                          localVector.fromArray(gamepad.pose.position);
                          localQuaternion.fromArray(gamepad.pose.orientation);
                          const distance = localVector
                            .distanceTo(
                              localVector2
                                .fromArray(tab.iframe.xrOffset.position)
                            );
                          scrollFactors[i] = distance;

                          const scale = tab.iframe.xrOffset.scale[0];
                          scaleFactors[i] = scale;
                        }

                        intersectionSpecs[i] = null;
                      });
                    } else {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          focusedTab = tabs[menuMesh.listMesh.scrollIndex + j];

                          menuMesh.urlMesh.updateText();
                          menuMesh.listMesh.updateList();
                        }

                        intersectionSpecs[i] = null;
                      });
                    }

                    break;
                  }
                }
              } else if (menuMesh.optionsMesh.list === 'links') {
                const localLinks = links.slice(menuMesh.listMesh.scrollIndex, menuMesh.listMesh.scrollIndex + 4);
                for (let j = 0; j < localLinks.length; j++) {
                  if (y >= urlBarOffset*j && y < urlBarOffset*(j+1)) {
                    intersectionPoints.push(intersectionPoint.clone());
                    intersectionCbs.push(() => {
                      controllerMesh.rayMesh.scale.z = distance;
                      controllerMesh.updateMatrixWorld();

                      const gamepads = navigator.getGamepads();
                      const gamepad = gamepads[i];
                      const pressed = gamepad.buttons[1].pressed;
                      const lastPressed = lastPresseds[i];
                      if (pressed && !lastPressed) {
                        const link = localLinks[j];
                        const {url} = link;

                        const {position, quaternion, scale} = _getFrontOfCamera();
                        _openUrl(url, position, quaternion, scale, menuMesh.optionsMesh.d);

                        menuMesh.optionsMesh.list = 'tabs';
                        menuMesh.optionsMesh.updateOptions();
                        menuMesh.listMesh.scrollIndex = 0;

                        _updateRigLists();
                      }

                      intersectionSpecs[i] = null;
                    });

                    break;
                  }
                }
              } else if (menuMesh.optionsMesh.list === 'party') {
                if (!serverConnectedUrl) {
                  const localServers = servers.slice(menuMesh.listMesh.scrollIndex, menuMesh.listMesh.scrollIndex + 4);
                  for (let j = 0; j < localServers.length; j++) {
                    if (y >= urlBarOffset*j && y < urlBarOffset*(j+1)) {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          const server = localServers[j];
                          const {name} = server;

                          _openServer(`${registryUrl}/servers/${name}`, true);
                        }

                        intersectionSpecs[i] = null;
                      });

                      break;
                    }
                  }
                } else {
                  if (y >= 0 && y < urlBarOffset) {
                    if (x >= menuWidth*0.8) {
                      intersectionPoints.push(intersectionPoint.clone());
                      intersectionCbs.push(() => {
                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[i];
                        const pressed = gamepad.buttons[1].pressed;
                        const lastPressed = lastPresseds[i];
                        if (pressed && !lastPressed) {
                          _closeServer();
                        }

                        intersectionSpecs[i] = null;
                      });
                    }
                  }
                }
              }
            } else {
              intersectionPoints.push(intersectionPoint.clone());
              intersectionCbs.push(() => {
                controllerMesh.rayMesh.scale.z = distance;
                controllerMesh.updateMatrixWorld();

                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[i];
                const pressed = gamepad.buttons[1].pressed;
                if (pressed) {
                  const list = menuMesh.optionsMesh.list === 'tabs' ? tabs : links;
                  menuMesh.listMesh.scrollIndex = Math.floor(yFactor*list.length);
                  if (menuMesh.listMesh.scrollIndex >= list.length) {
                    menuMesh.listMesh.scrollIndex = list.length;
                  }
                  menuMesh.listMesh.updateList();
                }

                intersectionSpecs[i] = null;
              });
            }
          }
        }
      }

      if (intersectionPoints.length > 0) {
        const intersectionCb = intersectionPoints
          .map((a, i) => ({
            distance: a.distanceTo(controllerMesh.position),
            cb: intersectionCbs[i],
          }))
          .sort((a, b) => a.distance - b.distance)[0].cb;
        intersectionCb();
      } else {
        _setIntersectionDefault();
      }

      const gamepads = navigator.getGamepads();
      const gamepad = gamepads[i];
      if (gamepad) {
        const pressed = gamepad.buttons[1].pressed;
        const padPressed = gamepad.buttons[0].pressed;
        const padTouched = gamepad.buttons[0].touched;

        const {axes} = gamepad;
        const lastPadTouched = lastPadToucheds[i];
        const lastAxis = lastAxes[i];
        if (padTouched && lastPadTouched && rig.open && !moves[i]) {
          const dx = axes[0] - lastAxis[0];
          const dy = axes[1] - lastAxis[1];

          rig.menuMesh.listMesh.updateWheel(dx*4, dy*4);
        }
        lastPresseds[i] = pressed; // XXX
        // lastPadToucheds[i] = padTouched;

        if (padPressed && moves[i]) {
          if (padPressed) {
            if (gamepad.axes[1] > 0.5) {
              scrollFactors[i] += 1/20;
            } else if (gamepad.axes[1] < -0.5) {
              scrollFactors[i] -= 1/20;
            } else if (gamepad.axes[0] > 0.5) {
              scaleFactors[i] = Math.min(scaleFactors[i] *= 1.02, 100);
            } else if (gamepad.axes[0] < -0.5) {
              scaleFactors[i] = Math.max(scaleFactors[i] /= 1.02, 0.01);
            }
          }
        }

        lastAxis[0] = axes[0];
        lastAxis[1] = axes[1];
      }
    }
  };
  _updateIntersections();

  const _updateButtons = () => {
    if (display) {
      for (let i = 0; i < gamepads.length && i < 2; i++) {
        const gamepad = gamepads[i];

        {
          const trigger = gamepad.buttons[1].pressed;
          const lastTrigger = lastButtons[i].trigger;

          if (trigger && !lastTrigger) {
            const spec = intersectionSpecs[i];
            if (spec && spec.type === 'key') {
              const {data: {key, rig}} = spec;
              const {menuMesh: {urlMesh, optionsMesh}} = rig;

              if (focusedTab === rig.menuMesh.urlMesh) {
                if (key !== 'enter') {
                  const code = keyCode(key);
                  rig.menuMesh.urlMesh.handleKey(code, false);
                } else {
                  const u = (optionsMesh.d === 3 && urlMesh.urlState.text === DEFAULT_URL) ? 'realitytab.html?color=29b6f6' : urlMesh.urlState.text;
                  const {position, quaternion, scale} = _getFrontOfCamera();
                  _openUrl(u, position, quaternion, scale, optionsMesh.d);
                  _updateRigLists();
                }
              } else if (focusedTab.iframe) {
                let code = keyCode(key);
                const opts = {
                  shiftKey: false,
                  ctrlKey: false,
                  altKey: false,
                };
                focusedTab.iframe.sendKeyDown(code, opts);
                focusedTab.iframe.sendKeyPress(code + 32, opts);
                focusedTab.iframe.sendKeyUp(code, opts);
              }
            }
          }

          lastButtons[i].trigger = trigger;
        }
        {
          const bumper = gamepad.buttons[2].pressed;
          const lastBumper = lastButtons[i].bumper;

          if (bumper && !lastBumper) {
            const {position, quaternion} = _getFrontOfCamera();
            localEuler.setFromQuaternion(quaternion, localEuler.order);
            localEuler.x = 0;
            localEuler.z = 0;
            quaternion.setFromEuler(localEuler);
            _openRig(position, quaternion);
          }

          lastButtons[i].bumper = bumper;
        }
      }
    }
  };
  _updateButtons(); */

  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      // console.log('got pos', orbitControls.object.position.toArray().join(',')); // XXX
      fakeXrDisplay.position.copy(orbitControls.object.position);
      fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);
      fakeXrDisplay.pushUpdate();
    }
  };
  _updateOrbitControls();

  /* const _updateMenu = () => {
    for (let i = 0; i < 2; i++) {
      const controllerMesh = controllerMeshes[i];
      controllerMesh.update();
      const menuCoord = menuCoords[i];

      const intersectionPoint = controllerMesh.ray.intersectPlane(menuMesh.plane, localVector);

      if (intersectionPoint) {
        const leftIntersectionPoint = menuMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

        const topIntersectionPoint = menuMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

        const xFactor = topIntersectionPoint.distanceTo(menuMesh.topLine.start) / 2;
        const yFactor = leftIntersectionPoint.distanceTo(menuMesh.leftLine.start);
        const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

        if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
          const x = xFactor * menuIframe.width;
          const y = yFactor * menuIframe.height;
          menuCoord.set(x, y);

          controllerMesh.dotMesh.position.z = -distance;
          controllerMesh.dotMesh.updateMatrixWorld();
          controllerMesh.dotMesh.visible = true;

          controllerMesh.rayMesh.scale.z = distance;
          controllerMesh.rayMesh.updateMatrixWorld();
        } else {
          controllerMesh.dotMesh.visible = false;

          controllerMesh.rayMesh.scale.z = 1;
          controllerMesh.rayMesh.updateMatrixWorld();

          menuCoord.set(-1, -1);
        }
      } else {
        controllerMesh.dotMesh.visible = false;

        controllerMesh.rayMesh.scale.z = 1;
        controllerMesh.rayMesh.updateMatrixWorld();

        menuCoord.set(-1, -1);
      }
    }
  };
  _updateMenu(); */

  const _updateLabels = () => {
    for (let i = 0; i < 2; i++) {
      const controllerMesh = controllerMeshes[i];
      controllerMesh.update();

      let found = false;
      for (let j = 0; j < roomLabels.length; j++) {
        const labelMesh = roomLabels[j];

        const intersectionPoint = controllerMesh.ray.intersectPlane(labelMesh.plane, localVector);
        if (intersectionPoint) {
          const leftIntersectionPoint = labelMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

          const topIntersectionPoint = labelMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

          const xFactor = topIntersectionPoint.distanceTo(labelMesh.topLine.start);
          const yFactor = leftIntersectionPoint.distanceTo(labelMesh.leftLine.start) / 0.1;
          const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

          if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
            const x = xFactor * menuIframe.width;
            const y = yFactor * menuIframe.height;
            intersectionSpecs[i] = {
              type: 'label',
              data: {
                labelMesh,
                x,
                y,
              },
            };

            controllerMesh.dotMesh.position.z = -distance;
            controllerMesh.dotMesh.updateMatrixWorld();
            controllerMesh.dotMesh.visible = true;

            controllerMesh.rayMesh.scale.z = distance;
            controllerMesh.rayMesh.updateMatrixWorld();

            found = true;
            break;
          }
        }
      }
      if (!found) {
        controllerMesh.dotMesh.visible = false;

        controllerMesh.rayMesh.scale.z = 1;
        controllerMesh.rayMesh.updateMatrixWorld();

        intersectionSpecs[i] = null;
      }
    }
  };
  _updateLabels();

  const _handleTrigger = (gamepad, i, pressed, lastPressed) => {
    const start = pressed && !lastPressed;
    const end = lastPressed && !pressed;

    if (toolMesh.tool === 'browser') {
      if (start) {
        // const location = targetMesh.material.uniforms.worldPos.value;
        const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
        const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
        const browser = _makeBrowserMesh(p.x, p.y, p.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w, 0x9ccc65);
        scene.add(browser);
        // rooms.push(browser);
        pendingRooms[i] = browser;
      } else if (end) {
        const browser = pendingRooms[i];
        pendingRooms[i] = null;
        const labelMesh = _makeLabelMesh('https://google.com');
        labelMesh.position.copy(browser.position);
        labelMesh.position.y += 0.1;
        labelMesh.rotation.setFromQuaternion(browser.quaternion, 'YXZ');
        labelMesh.rotation.x = 0;
        labelMesh.updateMatrixWorld();
        labelMesh.update();
        scene.add(labelMesh);
        roomLabels.push(labelMesh);
      } else {
        const browser = pendingRooms[i];
        if (browser) {
          const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
          browser.setEnd(c.position.x, c.position.y, c.position.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w);
          // console.log('update room', targetMesh.material.uniforms.worldPos.value.toArray().join(','));
        }
      }
    } else {
      const menuCoord = menuCoords[i];
      if (menuCoord.x !== -1) {
        if (start) {
          const button = 0;
          menuIframe.sendMouseDown(menuCoord.x, menuCoord.y, button);
        } else if (end) {
          const button = 0;
          menuIframe.sendMouseUp(menuCoord.x, menuCoord.y, button);
          menuIframe.sendClick(menuCoord.x, menuCoord.y, button);
        } else {
          menuIframe.sendMouseMove(menuCoord.x, menuCoord.y);
        }
      } else {
        if (start) {
          const location = targetMesh.material.uniforms.worldPos.value;
          const room = _makeRoomMesh(location.x, location.y, location.z, location.x, location.y, location.z, 0x9ccc65);
          scene.add(room);
          rooms.push(room);
          pendingRooms[i] = room;
        } else if (end) {
          const room = pendingRooms[i];
          room.setColor(0x5c6bc0);
          pendingRooms[i] = null;
          const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, room);
          scene.add(roomLinkMesh);
          roomLinks.push(roomLinkMesh);
          const roomDiagramMesh = _makeRoomDiagramMesh(roomDiagrams.length, room.classify(), 'tutorial.html', 0xffee58);
          scene.add(roomDiagramMesh);
          roomDiagrams.push(roomDiagramMesh);
          _addVolume(room);
          // console.log('end room', room.classify(), targetMesh.material.uniforms.worldPos.value.toArray().join(','));

          menuIframe.contentWindow.postMessage({
            method: 'tabs',
            tabs: roomDiagrams.map(roomDiagram => roomDiagram.label),
          });
        } else {
          const room = pendingRooms[i];
          if (room) {
            const location = targetMesh.material.uniforms.worldPos.value;
            room.setEnd(location.x, location.y, location.z);
            // console.log('update room', targetMesh.material.uniforms.worldPos.value.toArray().join(','));
          }
        }
      }
    }
  };
  const _makeMenuAnimation = spec => {
    const startTime = Date.now();
    const endTime = startTime + 150;
    const curve = cubicBezier(0, 1, 0, 1);
    return {
      spec,
      getValue() {
        return Math.min(Math.max(curve((Date.now() - startTime) / (endTime - startTime)), 0), 1);
      },
    };
  };
  const _updateGridControls = () => {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];

      if (gamepad.hand === 'right') {
        const pressed = gamepad.buttons[1].pressed;
        const lastPressed = lastPresseds[i];
        _handleTrigger(gamepad, i, pressed, lastPressed);
        lastPresseds[i] = pressed;
      }

      const bumper = gamepad.buttons[2].pressed;
      const lastBumper = lastButtons[i].bumper;

      if (bumper && !lastBumper) {
        const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
        c.matrixWorld.decompose(localVector, localQuaternion, localVector2);
        localVector.add(localVector2.set(0, 0, -1).applyQuaternion(localQuaternion));

        menuAnimation = _makeMenuAnimation({
          start: {
            position: menuMesh.position.clone(),
            quaternion: menuMesh.quaternion.clone(),
            scale: new THREE.Vector3(1, 1, 1),
          },
          end: {
            position: localVector.clone(),
            quaternion: localQuaternion.clone(),
            scale: new THREE.Vector3(1, 1, 1),
          },
        });
      }
      lastButtons[i].bumper = bumper;

      if (menuAnimation) {
        const {spec: {start, end}} = menuAnimation;
        const f = menuAnimation.getValue();

        menuMesh.quaternion.copy(start.quaternion).slerp(end.quaternion, f);
        menuMesh.position.copy(start.position).lerp(end.position, f);
        menuMesh.scale.copy(start.scale).lerp(end.scale, f);
        menuMesh.updateMatrixWorld();
        menuMesh.update();

        trayMesh.quaternion.copy(start.quaternion).slerp(end.quaternion, f);
        trayMesh.position.copy(start.position)
          .add(localVector.set(0, -0.5, 0.2/2).applyQuaternion(start.quaternion))
          .lerp(
            localVector.copy(end.position)
              .add(localVector2.set(0, -0.5, 0.2/2).applyQuaternion(end.quaternion)),
            f
          );
        trayMesh.scale.copy(start.scale).lerp(end.scale, f);
        trayMesh.updateMatrixWorld();

        if (f >= 1) {
          menuAnimation = null;
        }
      }

      const location = targetMesh.material.uniforms.worldPos.value;
      const cubeLocation = localVector.set(Math.floor(location.x), Math.floor(location.y), Math.floor(location.z));
      for (let i = 0; i < rooms.length; i++) {
        const room = rooms[i];
        const isPending = pendingRooms.some(pendingRoom => pendingRoom === room);
        if (!isPending) {
          room.setHighlight(room.contains(cubeLocation));
        }
      }
    }
  };
  _updateGridControls();

  for (let i = 0; i < volumeMeshes.length; i++) {
    const volumeMesh = volumeMeshes[i];
    const {iframe: volumeIframe} = volumeMesh;

    if (volumeIframe.contentWindow && volumeIframe.contentWindow.framebuffer) {
      const {tex, width, height} = volumeIframe.contentWindow.framebuffer;
      if (!volumeMesh.material.uniforms.uTex.value) {
        {
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearFilter,
            THREE.LinearFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            16
          );
          const properties = renderer.properties.get(texture);
          properties.__webglTexture = {
            id: volumeIframe.contentWindow.framebuffer.tex,
          };
          properties.__webglInit = true;

          volumeMesh.material.uniforms.uTex.value = texture;
        }
        {
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearFilter,
            THREE.LinearFilter,
            THREE.DepthStencilFormat,
            THREE.UnsignedInt248Type,
            16
          );
          const properties = renderer.properties.get(texture);
          properties.__webglTexture = {
            id: volumeIframe.contentWindow.framebuffer.depthTex,
          };
          properties.__webglInit = true;

          volumeMesh.material.uniforms.uDepthTex.value = texture;
        }
      }

      const w = cameraViewport[0] * 2;
      const h = cameraViewport[1];
      volumeMesh.material.uniforms.uViewport.value.set(w, h);
    }
  }
  for (let i = 0; i < portalMeshes.length; i++) {
    const portalMesh = portalMeshes[i];
    const {iframe: portalIframe} = portalMesh;

    if (portalIframe.contentWindow && portalIframe.contentWindow.framebuffer) {
      const {tex/*, width, height*/} = portalIframe.contentWindow.framebuffer;
      if (!portalMesh.material.uniforms.uTex.value) {
        {
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearFilter,
            THREE.LinearFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            16
          );
          const properties = renderer.properties.get(texture);
          properties.__webglTexture = {
            id: portalIframe.contentWindow.framebuffer.tex,
          };
          properties.__webglInit = true;

          portalMesh.material.uniforms.uTex.value = texture;
        }
        {
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearFilter,
            THREE.LinearFilter,
            THREE.DepthStencilFormat,
            THREE.UnsignedInt248Type,
            16
          );
          const properties = renderer.properties.get(texture);
          properties.__webglTexture = {
            id: portalIframe.contentWindow.framebuffer.depthTex,
          };
          properties.__webglInit = true;

          portalMesh.material.uniforms.uDepthTex.value = texture;
        }
      }

      const w = cameraViewport[0] * 2;
      const h = cameraViewport[1];
      portalMesh.material.uniforms.uViewport.value.set(w, h);
    }
  }

  const _render = () => {
    const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;

    gridMesh.material.uniforms.uTime.value = (gridMesh.material.uniforms.uTime.value + 0.1) % 14;
    targetMesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;
    c.matrixWorld.decompose(targetMesh.material.uniforms.worldPos.value, localQuaternion, localVector2);
    targetMesh.material.uniforms.worldPos.value
      .add(localVector2.set(0, 0, -3).applyQuaternion(localQuaternion));
    targetMesh.material.uniforms.worldPos.value.x = Math.floor(targetMesh.material.uniforms.worldPos.value.x + 0.5);
    targetMesh.material.uniforms.worldPos.value.y = Math.floor(targetMesh.material.uniforms.worldPos.value.y + 0.5);
    targetMesh.material.uniforms.worldPos.value.z = Math.floor(targetMesh.material.uniforms.worldPos.value.z + 0.5);
    for (let i = 0; i < roomLinks.length; i++) {
      roomLinks[i].update();
    }
    for (let i = 0; i < roomDiagrams.length; i++) {
      roomDiagrams[i].update();
    }

    renderer.render(scene, c);
  };
  _render();

  const _updateMovement = () => {
    if (fakeXrDisplay) {
      // if (window.document.pointerLockElement) {
        // let moving = false;
        const speed = 0.004;
        const velocity = localVector.set(0, 0, 0);
        if (keys.up) {
          velocity.z -= speed * timeDiff;
          // moving = true;
        }
        if (keys.down) {
          velocity.z += speed * timeDiff;
          // moving = true;
        }
        if (keys.left) {
          velocity.x -= speed * timeDiff;
          // moving = true;
        }
        if (keys.right) {
          velocity.x += speed * timeDiff;
          // moving = true;
        }
        if (keys.space) {
          velocity.y += speed * timeDiff;
          // moving = true;
        }
        if (keys.ctrl) {
          velocity.y -= speed * timeDiff;
          // moving = true;
        }

        // if (moving) {
          // velocity.multiplyScalar(Math.pow(moving ? 0.98 : 0.91, timePassed / 5));
          localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
          localEuler.x = 0;
          fakeXrDisplay.position.add(
            localVector.copy(velocity)
              .applyEuler(localEuler)
          );
          fakeXrDisplay.pushUpdate();
        // }
      // }
    }
  };
  _updateMovement();

  const _updateRig = () => {
    if (rig.animation) {
      rig.animation.update();
    }

    const iconMeshRotation = (Date.now() % 1000) / 1000 * Math.PI * 2;
    for (let i = 0; i < iconMeshes.length; i++) {
      const iconMesh = iconMeshes[i];
      const child = iconMesh.children[0];
      if (child) {
        child.rotation.y = iconMeshRotation;
      }
    }
  };
  _updateRig();

  const _updateMp = () => {
    /* const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
    vrCamera.matrixWorld.decompose(localVector, localQuaternion, localVector2);
    localSkinMesh.update(vrCamera, controllerMeshes); */

    if (serverConnectedUrl) {
      const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
      vrCamera.matrixWorld.decompose(xrmp.localPlayerMesh.hmd.position, xrmp.localPlayerMesh.hmd.quaternion, localVector2);

      for (let i = 0; i < 2; i++) {
        const controllerMesh = controllerMeshes[i];
        xrmp.localPlayerMesh.gamepads[i].visible = true;
        xrmp.localPlayerMesh.gamepads[i].position.copy(controllerMesh.position);
        xrmp.localPlayerMesh.gamepads[i].quaternion.copy(controllerMesh.quaternion);
      }

      xrmp.pushUpdate();

      const playerMeshes = xrmp.getRemotePlayerMeshes();
      for (let i = 0; i < playerMeshes.length; i++) {
        playerMeshes[i].animate();
      }
    }
  };
  _updateMp();

  lastTime = now;
}

// bootstrap

const _emitLayersVrDisplayActivate = () => {
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];

    if (layer.tagName === 'IFRAME' && layer.d === 3) {
      layer.contentWindow.runAsync('vrdisplayactivate');
    }
  }
};
const _emitLayersExitPresent = () => {
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];

    if (layer.tagName === 'IFRAME' && layer.d === 3) {
      layer.contentWindow.runAsync('exitPresent');
    }
  }
};
const _startFakeVrDisplay = async (width, height) => {
  if (typeof FakeXRDisplay !== 'undefined') {
    fakeXrDisplay = new FakeXRDisplay();
    if (isFinite(width)) {
      fakeXrDisplay.width = width;
    }
    if (isFinite(height)) {
      fakeXrDisplay.height = height;
    }
    fakeXrDisplay.position.set(0, 1.6, 0);
    fakeXrDisplay.pushUpdate();

    if (navigator.xr) {
      const session = await navigator.xr.requestSession({
        exclusive: true,
      });
      fakeXrDisplay.session = session;

      const _end = () => {
        renderer.vr.enabled = false;
        renderer.vr.setSession(null);
        renderer.vr.setAnimationLoop(null);

        _emitLayersExitPresent();

        session.removeEventListener('end', _end);
      };
      session.addEventListener('end', _end);

      await new Promise((accept, reject) => {
        session.requestAnimationFrame((timestamp, frame) => {
          session.layers = layers;

          renderer.vr.enabled = true;
          renderer.vr.setSession(session, {
            frameOfReferenceType: 'stage',
          });
          renderer.vr.setAnimationLoop(animate);

          const {width, height} = session.baseLayer.getViewport(frame.getViewerPose().views[0]);
          cameraViewport[0] = width;
          cameraViewport[1] = height;

          _emitLayersVrDisplayActivate();

          accept();
        });
      });
    } else {
      const displays = await navigator.getVRDisplays();
      const display = displays[0];
      await display.requestPresent([{
        source: renderer.domElement,
      }]);

      fakeXrDisplay.display = display;

      const _vrdisplaypresentchange = () => {
        _emitLayersExitPresent();

        display.removeEventListener('vrdisplaypresentchange', _vrdisplaypresentchange);
      };
      display.addEventListener('vrdisplaypresentchange', _vrdisplaypresentchange);

      display.layers = layers;

      renderer.vr.enabled = true;
      renderer.vr.setDevice(display);
      renderer.vr.setAnimationLoop(animate);
    }
  } else {
    fakeXrDisplay = {
      position: camera.position,
      quaternion: camera.quaternion,
      viewMatrix: camera.matrixWorld.toArray(),
      projectionMatrix: camera.projectionMatrix.toArray(),
      pushUpdate() {
        camera.updateMatrixWorld();

        localVector
          .copy(camera.position)
          .add(localVector2.set(0.5, -0.3, -0.5).applyQuaternion(camera.quaternion))
          .toArray(gamepad.pose.position);
        localQuaternion
          .copy(camera.quaternion)
          .toArray(gamepad.pose.orientation);
      },
    };

    renderer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, false);

    const gamepad = {
      hand: 'right',
      pose: {
        position: [0, 0, 0],
        orientation: [0, 0, 0, 1],
      },
      buttons: [
        {pressed: false},
        {pressed: false},
        {pressed: false},
        {pressed: false},
      ],
      connected: true,
    };
    navigator.getGamepads = () => [gamepad];

    window.addEventListener('mousedown', e => {
      gamepad.buttons[1].pressed = true;
    });
    window.addEventListener('mouseup', e => {
      gamepad.buttons[1].pressed = false;
    });

    renderer.setAnimationLoop(animate);
  }
};
const _endFakeVrDisplay = async () => {
  if (fakeXrDisplay.session) {
    await fakeXrDisplay.session.end();
  } else if (fakeXrDisplay.display) {
    await fakeXrDisplay.display.exitPresent();
  }

  fakeXrDisplay = null;

  // renderer.domElement.framebuffer = null; // XXX destroy this framebuffer
};
_startFakeVrDisplay()
  .then(() => {
    /* const tabUrl = (() => {
      const {t = 'tutorial.html'} = query;
      if (!/^[a-z]+:\/\//.test(t)) {
        return `../${t}`;
      } else {
        return t;
      }
    })();
    _openUrl(tabUrl);

    focusedTab = rig.menuMesh.urlMesh;
    rig.menuMesh.urlMesh.updateText();
    rig.menuMesh.listMesh.updateList(); */

    _bindEventTarget('ui');
    _initMenu();

    // const roomMesh = _makeRoomMesh(-8, 0, -8, 8, 4, 8, 0xffee58);
    const roomMesh = _makeRoomMesh(0, 0, 0, 0, 0, 0, 0xffee58);
    scene.add(roomMesh);
    rooms.push(roomMesh);

    const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, roomMesh);
    scene.add(roomLinkMesh);
    roomLinks.push(roomLinkMesh);

    const roomDiagramMesh = _makeRoomDiagramMesh(roomDiagrams.length, 'volume', 'tutorial.html', 0xffee58);
    scene.add(roomDiagramMesh);
    roomDiagrams.push(roomDiagramMesh);

    _addVolume(roomMesh);

    menuIframe.contentWindow.postMessage({
      method: 'tabs',
      tabs: roomDiagrams.map(roomDiagram => roomDiagram.label),
    });

    console.log('loaded fake display');
  })
  .catch(err => {
    console.warn(err.stack);
  });
/* (async () => {
  if (!query.fake) {
    if (navigator.xr) { // WebXR
      display = await navigator.xr.requestDevice();

      if (display) {
        const session = await display.requestSession({
          exclusive: true,
        });
        display.session = session;

        session.layers = layers;

        // console.log('request first frame');
        session.requestAnimationFrame((timestamp, frame) => {
          renderer.vr.setSession(session, {
            frameOfReferenceType: 'stage',
          });

          const viewport = session.baseLayer.getViewport(frame.views[0]);
          // const width = viewport.width;
          const height = viewport.height;
          const fullWidth = (() => {
            let result = 0;
            for (let i = 0; i < frame.views.length; i++) {
              result += session.baseLayer.getViewport(frame.views[i]).width;
            }
            return result;
          })();
          renderer.setSize(fullWidth, height);

          renderer.setAnimationLoop(null);

          renderer.vr.enabled = true;
          renderer.vr.setDevice(display);
          renderer.vr.setAnimationLoop(animate);

          if (window.browser && window.browser.magicleap) {
            window.browser.magicleap.RequestDepthPopulation(true);
            // renderer.autoClearDepth = false;
          }

          _openUrl('tutorial.html');
          _updateRigLists();

          console.log('loaded root in XR');
        });
      } else {
        console.log('no xr displays');
        await _bootFakeDisplay();
      }
    } else { // WebVR
      console.log('request device');
      const displays = await navigator.getVRDisplays();
      display = displays[0];

      if (display) {
        console.log('request present');
        await display.requestPresent([
          {
            source: renderer.domElement,
          }
        ]);
        console.log('entered vr');

        display.layers = layers;

        const {renderWidth: width, renderHeight: height} = display.getEyeParameters('left');
        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);
        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        if (window.browser && window.browser.magicleap) {
          window.browser.magicleap.RequestDepthPopulation(true);
          // renderer.autoClearDepth = false;
        }

        _openUrl('tutorial.html');
        _updateRigLists();

        console.log('loaded root in XR');
      } else {
        console.log('no vr displays');
        await _bootFakeDisplay();
      }
    }
  } else {
    await _bootFakeDisplay();
  }
})()
  .catch(err => {
    console.warn(err.stack);
  }); */

// renderer.setAnimationLoop(animate);
// _openRig(new THREE.Vector3(0, 1.5, -1), new THREE.Quaternion());
})();
    </script>
    <audio src="background.mp3" autoplay loop></audio>
  </body>
</html>
