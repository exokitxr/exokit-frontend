<!doctype html>
<html>
  <head>
    <style>
body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  overflow: hidden;
}
#canvas {
  width: 100vw;
  height: 100vh;
}
iframe, audio {
  display: none;
}
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script>
    <script src="BufferGeometryUtils.js"></script>
    <!-- <script src="GLTFLoader.js"></script> -->
    <script src="bmfont.js"></script>
    <script src="keycode.js"></script>
    <script src="svg-boundings.js"></script>
    <script src="cubicBezier.js"></script>
    <!-- <script src="sprite3d.js"></script>
    <script src="skin.js"></script> -->
    <script>
(async () => {
let session, display, fakeXrDisplay, tabs = [], tabId = 0, xrmp, lastPresseds = [false, false], lastGripped = [false, false], lastAxes = [[0.5, 0.5], [0.5, 0.5]], lastPadToucheds = [false, false], scrollFactors = [0, 0], scaleFactors = [1, 1], viewportVector = new THREE.Vector2(), menuOpen = false, /* menuCoords = [new THREE.Vector2(-1, -1), new THREE.Vector2(-1, -1)], */ orbitControls = null, transformControls, rooms = [], pointMeshes = [], pendingRooms = [null, null], roomLinks = [], roomDiagrams = [], roomLabels = [], guardianMeshes = [], baseMeshes = [], selectedBaseMesh = null, menuAnimation = null, menuFactor = 1, keyboardFocus = null;
const mouse = {
  position: new THREE.Vector3(),
  quaternion: new THREE.Quaternion(),
};
const scenes = [];

let servers = [];
let serversLoading = false;
let serverConnectedUrl = null;

const DEFAULT_URL = 'https://google.com';
const DEFAULT_REGISTRY_URL = 'http://xrmp.exokit.org:9001';
const DEFAULT_SKIN_URL = 'skin2.png';
const RAY_COLOR = 0x44c2ff;
const RAY_HIGHLIGHT_COLOR = new THREE.Color(RAY_COLOR).multiplyScalar(0.5).getHex();
const rayDistance = 3;
const menuWidth = 1024;
const menuHeight = menuWidth * 0.1;
const menuWorldWidth = 1;
const menuWorldHeight = menuWorldWidth / menuWidth * menuHeight;
const menuPositionHeight = 0.3;
const urlBarWidth = menuWorldWidth;
const urlBarHeight = menuHeight;
const urlBarOffset = urlBarHeight;
const fontFamily = 'Arial';
// const fontFamily = 'monospace';
const fontSize = 60;
const keyboardWidth = 2048;
const keyboardHeight = 716;
const keyboardMatrix = [keyboardWidth / 963.266, keyboardHeight / 337.215];
const cursorWidth = 4;
const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localVector2D = new THREE.Vector2();
const localQuaternion = new THREE.Quaternion();
const localQuaternion2 = new THREE.Quaternion();
const localEuler = new THREE.Euler(0, 0, 0, 'YXZ');
const localEuler2 = new THREE.Euler(0, 0, 0, 'YXZ');
const localMatrix = new THREE.Matrix4();
const localMatrix2 = new THREE.Matrix4();
const localLine = new THREE.Line3();
const localBox = new THREE.Box3();
const localRay = new THREE.Ray();
const localRaycaster = new THREE.Raycaster();
const localPlane = new THREE.Plane();

/* function parseQuery(s) {
  var query = {};
  var pairs = (s[0] === '?' ? s.substr(1) : s).split('&');
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split('=');
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
  }
  return query;
}
const query = parseQuery(window.location.search); */

// helpers

const _getFrontOfCamera = () => {
  const vrCamera = renderer.vr.enabled ? renderer.vr.getCamera(camera).cameras[0] : camera;
  vrCamera.matrixWorld.decompose(localVector, localQuaternion, localVector2);
  localVector.add(
    localVector2.set(0, 0, -1.5)
      .applyQuaternion(localQuaternion)
  );
  localVector2.set(1, 1, 1);

  return {
    position: localVector.clone(),
    quaternion: localQuaternion.clone(),
    scale: localVector2.clone(),
  };
};

const _makeBoxGeometry = (x = 1, y = 1, z = 1) => {
  const size = 1;
  const width = 0.005;

  const lineGeometry = new THREE.CylinderBufferGeometry(width, width, size, 3, 1);
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(lineGeometry.attributes.position.array.length * 12);
  geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, 0, -size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 0
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, 0, -size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 1
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, 0, size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 2
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, y, 1)
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, 0, size/2)
      )
      .attributes.position.array,
    lineGeometry.attributes.position.array.length * 3
  );
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, -size/2, -size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 4
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, -size/2, size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 5
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, size/2, -size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 6
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(x, 1, 1)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(0, size/2, size/2)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 7
  );
  // axis
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, -size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 8
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(-size/2, size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 9
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, -size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 10
  );
  positions.set(
    lineGeometry.clone()
      .applyMatrix(
        localMatrix.makeScale(1, 1, z)
      )
      .applyMatrix(
        localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
      )
      .applyMatrix(
        localMatrix.makeTranslation(size/2, size/2, 0)
      ).attributes.position.array,
    lineGeometry.attributes.position.array.length * 11
  );
  const numLinePositions = lineGeometry.attributes.position.array.length / 3;
  const indices = new Uint16Array(lineGeometry.index.array.length * 12);
  for (let i = 0; i < 12; i++) {
    indices.set(
      lineGeometry.index.array,
      lineGeometry.index.array.length * i
    );

    for (let j = 0; j < lineGeometry.index.array.length; j++) {
      lineGeometry.index.array[j] += numLinePositions;
    }
  }
  geometry.setIndex(new THREE.BufferAttribute(indices, 1));
  return geometry;
};
const boxMaterial = new THREE.MeshPhongMaterial({
  color: 0x333333,
});
const _makeBoxMesh = () => {
  const geometry = _makeBoxGeometry();
  const material = boxMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.visible = false;
  mesh.frustumCulled = false;
  return mesh;
};

const _makeGuardianMesh = scene => {
  const topGeometry = new THREE.BoxBufferGeometry(0.01, 1, 0.01);
  const leftGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0))
  ));
  const frontGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))
  ));
  const boxGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    // topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, 0.5)),
    // topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, 0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, -0.5)),
    // leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, -0.5)),
    // leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, -0.5)),
    /* frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)), */
  ]);
  const boxGeometries = [];
  for (let i = 0; i < scene.coords.length; i++) {
    const coord = scene.coords[i];
    const hasCoords = {
      left: scene.coords.some(coord2 => coord2[0] === coord[0]-1 && coord2[1] === coord[1]),
      right: scene.coords.some(coord2 => coord2[0] === coord[0]+1 && coord2[1] === coord[1]),
      up: scene.coords.some(coord2 => coord2[0] === coord[0] && coord2[1] === coord[1]-1),
      down: scene.coords.some(coord2 => coord2[0] === coord[0] && coord2[1] === coord[1]+1),
    };
    if (!hasCoords.up) {
      for (let x = coord[0]*6 - 3; x <= ((coord[0] + 1) * 6) - 3; x++) {
        for (let y = 0; y <= 2; y++) {
          const z = -3;
          boxGeometries.push(boxGeometry.clone()
            .applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z))
          );
        }
      }
    }
    if (!hasCoords.down) {
      for (let x = coord[0]*6 - 3; x <= ((coord[0] + 1) * 6) - 3; x++) {
        for (let y = 0; y <= 2; y++) {
          const z = 3;
          boxGeometries.push(boxGeometry.clone()
            .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)))
            .applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z))
          );
        }
      }
    }
    if (!hasCoords.left) {
      for (let z = coord[0]*6 - 3; z <= ((coord[1] + 1) * 6) - 3; z++) {
        for (let y = 0; y <= 2; y++) {
          const x = -3;
          boxGeometries.push(boxGeometry.clone()
            .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI/2)))
            .applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z))
          );
        }
      }
    }
    if (!hasCoords.right) {
      for (let z = coord[0]*6 - 3; z <= ((coord[1] + 1) * 6) - 3; z++) {
        for (let y = 0; y <= 2; y++) {
          const x = 3;
          boxGeometries.push(boxGeometry.clone()
            .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI/2)))
            .applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z))
          );
        }
      }
    }
  }
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(boxGeometries);
  const gridVsh = `
    varying vec3 vWorldPos;
    // varying vec2 vUv;
    varying float vDepth;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vUv = uv;
      vWorldPos = abs(position);
      vDepth = gl_Position.z / 2.0;
    }
  `;
  const gridFsh = `
    // uniform sampler2D uTex;
    uniform float uAnimation;
    varying vec3 vWorldPos;
    varying float vDepth;
    void main() {
      gl_FragColor = vec4(${new THREE.Color(scene.color/*0x5c6bc0*/).toArray().map(n => n.toFixed(8)).join(',')}, (1.0-vDepth)*uAnimation);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: gridVsh,
    fragmentShader: gridFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
};
const _makeBaseMesh = scene => {
  const planeGeometry = new THREE.PlaneBufferGeometry(7, 7)
    .applyMatrix(localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), -Math.PI/2)))
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.01, 0));
  const _makeGeometry = coords => THREE.BufferGeometryUtils.mergeBufferGeometries(coords.map(coord =>
    planeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(coord[0]*7, 0, coord[1]*7))
  ));
  const geometry = _makeGeometry(scene.coords);
  const baseVsh = `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    }
  `;
  const baseFsh = `
    uniform float uAnimation;
    void main() {
      gl_FragColor = vec4(${new THREE.Color(scene.color/*0x5c6bc0*/).toArray().map(n => n.toFixed(8)).join(',')}, uAnimation*0.5);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: baseVsh,
    fragmentShader: baseFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.addCoord = (x, y) => {
    const index = scene.coords.findIndex(coord => coord[0] === x && coord[1] === y);
    if (index === -1) {
      scene.coords.push([x, y])
    } else {
      scene.coords.splice(index, 1);
    }
    if (scene.coords.length > 0) {
      mesh.geometry = _makeGeometry(scene.coords);
      return true;
    } else {
      return false;
    }
  };
  mesh.destroy = () => {
    // XXX
  };
  return mesh;
};

const _openUrl = (u, position = new THREE.Vector3(), orientation = new THREE.Quaternion(), scale, d = 3, local = true, id = tabId++) => {
  if (scale === undefined) {
    scale = new THREE.Vector3(1, d === 3 ? 1 : window.innerHeight/window.innerWidth, 1);
    if (d !== 3) {
      scale.multiplyScalar(0.4);
    }
  }

  const _drawOk = () => {
    console.log('reality tab load ok: ' + u);

    _pushDomUpdate();
  };
  const _drawFail = () => {
    console.log('reality tab load error: ' + u);
  };

  const iframe = document.createElement('iframe');
  iframe.onconsole = (jsString, scriptUrl, startLine) => {
    console.log('parent got console', {jsString, scriptUrl, startLine});
  };
  iframe.onload = function() {
    const contentDocument = (() => {
      try {
        if (this.contentDocument) { // this potentially throws
          return this.contentDocument;
        } else {
          return null;
        }
      } catch(err) {
        console.warn(err.stack);
        return null;
      }
    })();
    if (contentDocument) {
      _drawOk();
    } else {
      _drawFail();

      _closeTab(tab);

      if (focusedTab === tab) {
        focusedTab = rig.menuMesh.urlMesh;
      }

      rig.menuMesh.urlMesh.updateText();
      _updateRigLists();
    }
  };
  iframe.d = d;
  iframe.src = u;

  const tab = _addTab(iframe, position, orientation, scale, d, local, id);
};
const _addScene = sceneSpec => {
  const guardianMesh = _makeGuardianMesh(sceneSpec);
  scene.add(guardianMesh);
  guardianMeshes.push(guardianMesh);
  const baseMesh = _makeBaseMesh(sceneSpec);
  _insertBefore(baseMesh, floorMesh);
  baseMeshes.push(baseMesh);
};
const _insertBefore = (a, b) => {
  scene.add(a);
  const aIndex = scene.children.indexOf(a);
  scene.children.splice(aIndex, 1);
  const bIndex = scene.children.indexOf(b);
  scene.children.splice(bIndex, 0, a);
};

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;

/* const cubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0xab47bc,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z = -5;
  mesh.rotation.order = 'YXZ';
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(cubeMesh); */

const skyboxMesh = (() => {
  const radius = 99;
  const timeFactor = 1000;
  const geometry = new THREE.SphereBufferGeometry(radius, 32, 32)
    .applyMatrix(new THREE.Matrix4().makeScale(-1, -1, -1));
  const skyboxVsh = `
    // uniform float uAnimation;
    varying vec3 vPosition;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vPosition = position;
      vUv = uv;
    }
  `;
  const skyboxFsh = `
    uniform float uAnimation;
    varying vec3 vPosition;
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(uAnimation);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: skyboxVsh,
    fragmentShader: skyboxFsh,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    material.uniforms.uTime.value = (Date.now() % timeFactor) / timeFactor;
  };
  return mesh;
})();
scene.add(skyboxMesh);

const floorMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(1000, 1000, 1000, 1000)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
    .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5))
    /* .toNonIndexed();
  const scenes = new Float32Array(geometry.attributes.position.array.length / 3);
  for (let x = -3; x <= 3; x++) {
    for (let z = -3; z <= 3; z++) {
      const ax = x + 500;
      const az = z + 500;
      const startIndex = ((ax * 1000) + az) * 6;
      const endIndex = startIndex + 6;
      scenes.fill(1, startIndex, endIndex);
    }
  }
  geometry.addAttribute('scene', new THREE.BufferAttribute(scenes, 1)); */
  const floorVsh = `
    uniform float uAnimation;
    // attribute float scene;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      float radius = sqrt(position.x*position.x + position.z*position.z);
      // vec3 p = vec3(position.x, position.y - (1.0 - uAnimation * radius), position.z);
      vec3 p = vec3(position.x, position.y - (1.0 - uAnimation) * radius, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position;
      // vScene = scene;
      vDepth = gl_Position.z / 200.0;
    }
  `;
  const floorFsh = `
    uniform float uAnimation;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      vec3 c;
      // if (vScene == 0.0) {
        c = vec3(0.8 + vDepth);
      /* } else {
        c = vec3(${new THREE.Color(0x7986cb).toArray().map(n => n.toFixed(8)).join(',')});
      } */
      float a;
      vec3 f = fract(vPosition + 0.5);
      if (f.x <= 0.01 || f.x >= 0.99 || f.z <= 0.01 || f.z >= 0.99) {
        // a = 0.0;
        discard;
      } else {
        a = uAnimation*0.5;
      }
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
  mesh.intersect = ray => {
    const point = ray.origin.y !== 0 ? ray.intersectPlane(mesh.plane, localVector) : null;
    if (point) {
      const distance = ray.origin.distanceTo(point);
      if (distance < 10) {
        const {x, z: y} = point;
        return {
          type: 'floor',
          mesh,
          point,
          distance,
          cancel: false,
          x,
          y,
        };
      } else {
        return null;
      }
    } else {
      return null;
    }
  };
  return mesh;
})();
scene.add(floorMesh);

const [
  layersImg,
  browserImg,
  mapImg,
  diceImg,
  cogsImg,
  arrowLeftImg,
  chevronLeftImg,
  chevronRightImg,
  timesImg,
  crosshairImg,
  plusImg,
  locationImg,
  xImg,
  faviconImg,
  keyboardImg,
  keyboardHighlightCanvasCtx,
  keyMap,
] = await Promise.all(
  [
    'layers.png',
    'browser.png',
    'map.png',
    'dice.png',
    'cogs.png',
    'arrow-left.png',
    'chevron-left.png',
    'chevron-right.png',
    'times.png',
    'crosshair.png',
    'plus.png',
    'location.png',
    'x.png',
    'https://cors-anywhere.herokuapp.com/https://google.com/favicon.ico',
    'keyboard.png',
  ].map(src => new Promise((accept, reject) => {
    const img = new Image();
    img.onload = () => {
      accept(img);
    };
    img.onerror = err => {
      reject(err);
    };
    img.crossOrigin = 'Anonymous';
    img.src = src;
  })).concat([
    new Promise((accept, reject) => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = 'keyboard-highlight.png';
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        accept(ctx);
      };
      img.onerror = err => {
        reject(err);
      };
    }),
    fetch('keyboard.svg')
      .then(res => res.text())
      .then(keyboardText => {
        const result = [];

        const div = document.createElement('div');
        div.innerHTML = keyboardText;
        const keyEls = div.querySelectorAll('svg > g[key]');
        for (let i = 0; i < keyEls.length; i++) {
          const keyEl = keyEls[i];
          const key = keyEl.getAttribute('key');
          const shapeEl = keyEl.children[0];
          const boundings = svgBoundings[shapeEl.tagName.toLowerCase()](shapeEl);
          const {
            left,
            right,
            top,
            bottom,
          } = boundings;
          const x1 = left * keyboardMatrix[0];
          const x2 = right * keyboardMatrix[0];
          const y1 = top * keyboardMatrix[1];
          const y2 = bottom * keyboardMatrix[1];
          result.push([key, x1, y1, x2, y2]);
        }

        return Promise.resolve(result);
      }),
  ])
);
const fontSpec = await Promise.all([
  fetch('DejaVu-sdf.json').then(res => res.json()),
  new Promise((accept, reject ) => {
    new THREE.TextureLoader().load('DejaVu-sdf.png', accept);
  }),
]).then(([font, texture]) => ({font, texture}));
const _makeTextMesh = (s = '', size = 1) => {
  const {font, texture} = fontSpec;

  // create a geometry of packed bitmap glyphs, 
  // word wrapped to 300px and right-aligned
  var geometry = createTextGeometry({
    width: Infinity,
    font,
  });

  // change text and other options as desired
  // the options sepcified in constructor will
  // be used as defaults
  geometry.update(s);

  // the resulting layout has metrics and bounds
  // console.log(geometry.layout.height)
  // console.log(geometry.layout.descender)

  var material = new THREE.RawShaderMaterial(createSDFShader({
    map: texture,
    transparent: true,
    color: 0xffffff,
    // color: palette[Math.floor(Math.random() * palette.length)]
    // negate: false,
    side: THREE.DoubleSide,
  }));

  const scaleFactor = 0.002 * size;

  const mesh = new THREE.Mesh(geometry, material)
  mesh.position.set(0, -geometry.layout.lineHeight * 0.001, 0);
  mesh.scale.set(scaleFactor, -scaleFactor, -scaleFactor);
  mesh.getText = () => s;
  mesh.setText = newS => {
    if (newS !== s) {
      s = newS;
      geometry.update(s);
      /* mesh.dispatchEvent({
        type: 'update',
        url: s,
      }); */
    }
  };
  return mesh;
};
/* const textMesh = _makeTextMesh('Lorem ipsum dolor sit amet');
textMesh.position.x -= 0.5;
textMesh.position.y += 1;
textMesh.frustumCulled = false;
scene.add(textMesh); */

const _makeCaretMesh = labelMesh => {
  const geometry = new THREE.PlaneBufferGeometry(0.005, 0.1)
    .applyMatrix(new THREE.Matrix4().makeTranslation(-labelMesh.width/2, 0, 0));
  const material = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z += 0.001;
  mesh.visible = false;
  mesh.frustumCulled = false;
  mesh.getValue = () => value;
  mesh.setValue = newValue => {
    value = newValue;

    const glyphs = labelMesh.getGlyphs();
    if (glyphs.length > 0) {
      if (value < glyphs.length) {
        mesh.position.x = glyphs[value].x * labelMesh.textMesh.scale.x;
      } else {
        mesh.position.x = glyphs[glyphs.length - 1].x * labelMesh.textMesh.scale.x;
      }
    } else {
      mesh.position.x = 0;
    }
  };
  return mesh;
};

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.y = 1.6;
// camera.position.z = 1;

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
renderer.domElement.id = 'canvas';
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const layers = [renderer.domElement];

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight2.position.set(-1, 1, -1);
scene.add(directionalLight2); */

const pointerMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]).applyMatrix(new THREE.Matrix4().makeScale(0.05, 0.05, 0.05));
  const targetVsh = `
    uniform vec3 worldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + worldPos, 1.);
    }
  `;
  const targetFsh = `
    uniform float uTime;
    void main() {
      gl_FragColor = vec4(vec3(min(pow(uTime, 0.5), 0.9)), 1.0);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      worldPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  // mesh.visible = false;
  return mesh;
})();
scene.add(pointerMesh);

/* const targetMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
  const targetVsh = `
    uniform vec3 worldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + worldPos, 1.);
    }
  `;
  const targetFsh = `
    uniform float uTime;
    void main() {
      gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      worldPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.visible = false;
  return mesh;
})();
scene.add(targetMesh); */

// events

const _addOrbitControls = () => {
  const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
  orbitControls = new THREE.OrbitControls(orbitCamera);
  orbitCamera.position.copy(fakeXrDisplay.position);
  orbitCamera.quaternion.copy(fakeXrDisplay.quaternion);
  scene.add(orbitCamera);
  orbitCamera.updateMatrixWorld();
  orbitControls.target.copy(orbitCamera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(orbitCamera.quaternion));
  orbitControls.screenSpacePanning = true;
  orbitControls.update();
};
const _removeOrbitControls = () => {
  scene.remove(orbitControls.object);
  orbitControls.dispose();
  orbitControls = null;
};

let unbindEvents = null;
const _bindEventTarget = target => {
  if (unbindEvents) {
    unbindEvents();
    unbindEvents = null;
  }

  const _bindEvents = (windowEvents = {}, documentEvents = {}) => {
    for (const k in windowEvents) {
      const fn = windowEvents[k];
      window.addEventListener(k, fn);
    }
    for (const k in documentEvents) {
      const fn = documentEvents[k];
      document.addEventListener(k, fn);
    }

    unbindEvents = () => {
      for (const k in windowEvents) {
        const fn = windowEvents[k];
        window.removeEventListener(k, fn);
      }
      for (const k in documentEvents) {
        const fn = documentEvents[k];
        document.removeEventListener(k, fn);
      }
    };
  };
  if (target === 'ui') {
    /* const _addTransformControls = (camera, iframe) => {
      transformControls = new THREE.TransformControls(camera, document.body, viewport);
      transformControls.iframe = iframe;

      transformControls.addEventListener('dragging-changed', e => {
        orbitControls.enabled = !e.value;
      });
      transformControls.addEventListener('change', e => {
        iframe.position = mesh.position.toArray();
        iframe.orientation = mesh.quaternion.toArray();
        iframe.scale = mesh.scale.toArray();
      });

      const mesh = new THREE.Object3D();
      mesh.position.fromArray(_parseVector(iframe.position));
      mesh.quaternion.fromArray(_parseVector(iframe.orientation));
      mesh.scale.fromArray(_parseVector(iframe.scale));
      scene.add(mesh);
      mesh.updateMatrixWorld();

      transformControls.attach(mesh);
      scene.add(transformControls);
    };
    const _removeTransformControls = () => {
      scene.remove(transformControls.object);
      scene.remove(transformControls);
      transformControls.dispose();
      transformControls = null;
    }; */

    _bindEvents({
      mousemove(e) {
        if (fakeXrDisplay) {
          const localCamera = camera;
          localCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
          localCamera.matrixWorld.getInverse(localCamera.matrixWorldInverse);
          localCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
          localCamera.projectionMatrixInverse.getInverse(localCamera.projectionMatrix);

          let xFactor = e.clientX / window.innerWidth;
          if (window.FakeXRDisplay) {
            xFactor = (xFactor % 0.5) * 2;
          }
          const yFactor = -e.clientY / window.innerHeight;
          localVector2D.set(xFactor * 2 - 1, yFactor * 2 + 1);
          localRaycaster.setFromCamera(localVector2D, localCamera);

          // console.log('set mouse', localVector2D.toArray(), localRaycaster.ray.origin.toArray(), localRaycaster.ray.direction.toArray());
          mouse.position.copy(localRaycaster.ray.origin);
          mouse.quaternion.setFromUnitVectors(localVector.set(0, 0, -1), localRaycaster.ray.direction);
        }
      },
      /* mousemove(e) {
        const localCamera = camera;
        localCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
        localCamera.matrixWorld.getInverse(localCamera.matrixWorldInverse);
        localCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
        localCamera.projectionMatrixInverse.getInverse(localCamera.projectionMatrix);

        localCamera.matrixWorld.decompose(localCamera.position, localCamera.quaternion, localCamera.scale);
        const rect = document.body.getBoundingClientRect();
        localRaycaster.setFromCamera(
          localVector2D.set(
            ((e.clientX / rect.width) % 0.5 * 2) * 2 - 1,
            (-e.clientY / rect.height) * 2 + 1
          ),
          localCamera
        );
        const line = localLine.set(
          localRaycaster.ray.origin,
          localVector.copy(localRaycaster.ray.origin)
            .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(100))
        );
        const distanceSpecs = layers.map(layer => {
          if (layer.tagName === 'IFRAME') {
            line.closestPointToPoint(localVector.fromArray(_parseVector(layer.position)), true, localVector2);
            const distance = localVector.distanceTo(localVector2);
            if (distance < 1) {
              return {
                iframe: layer,
                distance,
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        }).filter(spec => !!spec).sort((a, b) => a.distance - b.distance);
        const closestIframe = distanceSpecs.length > 0 ? distanceSpecs[0].iframe : null;
        const shouldTransform = (!!transformControls && transformControls.dragging) || !!closestIframe;
        if (shouldTransform && (!transformControls || (transformControls.iframe !== closestIframe && !transformControls.dragging))) {
          if (transformControls) {
            _removeTransformControls();
          }

          _addTransformControls(localCamera, closestIframe);
        } else if (!shouldTransform && transformControls) {
          _removeTransformControls();
        }
      }, */
      keydown(e) {
        if (keyboardFocus) {
          _handleKey(e.keyCode, e.shiftKey);
        } else {
          switch (e.which) {
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = true;
              }
              break;
            }
            case 70: { // F
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = true;
              }
              break;
            }
            case 82: { // R
              _endFakeVrDisplay()
                .then(() => _enterXr())
                .catch(err => {
                  console.warn(err.stack);
                });
              break;
            }
          }
        }
      },
      keyup(e) {
        if (!keyboardFocus) {
          switch (e.which) {
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = false;
              }
              break;
            }
            case 70: { // F
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = false;
              }
              break;
            }
          }
        }
      },
      dblclick(e) {
        if (!window.document.pointerLockElement && !(intersectionSpecs[1] && intersectionSpecs[1].cancel)) {
          renderer.domElement.requestPointerLock();
        }
      },
    }, {
      pointerlockchange(e) {
        if (window.document.pointerLockElement) {
          _bindEventTarget('xr');
        }
      },
    });

    _addOrbitControls();
    unbindEvents = (unbindEvents => function() {
      unbindEvents.apply(this, arguments);
      _removeOrbitControls();
    })(unbindEvents);
  } else if (target === 'xr') {
    _bindEvents({
      /* click(e) {
        renderer.domElement.requestPointerLock();
      }, */
      mousedown(e) {
        if (window.document.pointerLockElement) {
          const gamepads = navigator.getGamepads();
          if (gamepads[1]) {
            gamepads[1].buttons[1].pressed = true;
          }
        }
      },
      mouseup(e) {
        if (window.document.pointerLockElement) {
          const gamepads = navigator.getGamepads();
          if (gamepads[1]) {
            gamepads[1].buttons[1].pressed = false;
          }
        }
      },
      mousemove(e) {
        if (window.document.pointerLockElement) {
          const {movementX, movementY} = e;

          /* if (keys.ctrl) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.y -= movementY * 0.002;
          } else if (keys.alt) {
            const controllerOffset = controllerOffsets[controllerIndex];
            controllerOffset.x += movementX * 0.002;
            controllerOffset.z += movementY * 0.002;
          } else { */
            localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
            localEuler.y -= movementX * 0.01;
            localEuler.x -= movementY * 0.01;
            localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
            fakeXrDisplay.quaternion.setFromEuler(localEuler);

            fakeXrDisplay.pushUpdate();
          // }
        }
      },
      wheel(e) {
        if (window.document.pointerLockElement) {
          rig.menuMesh.listMesh.updateWheel(e.deltaX/100, -e.deltaY/100);
        }
      },
      keydown(e) {
        // if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 83: { // S
              keys.down = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 65: { // A
              keys.left = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 68: { // D
              keys.right = true;
              /* if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              } */
              break;
            }
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = true;
              }
              break;
            }
            case 70: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = true;
              }
              break;
            }
            case 32: { // space
              keys.space = true;
              break;
            }
            case 17: { // ctrl
              keys.ctrl = true;
              break;
            }
            /* case 49: // 1
            case 50: // 2
            case 51: // 3
            case 52: // 4
            {
              toolMesh.setTool(e.which - 48);
              break;
            } */
          }
        // }
      },
      keyup(e) {
        // if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = false;
              break;
            }
            case 83: { // S
              keys.down = false;
              break;
            }
            case 65: { // A
              keys.left = false;
              break;
            }
            case 68: { // D
              keys.right = false;
              break;
            }
            case 69: { // E
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[5].pressed = false;
              }
              break;
            }
            case 70: { // F
              const gamepads = navigator.getGamepads();
              if (gamepads[1]) {
                gamepads[1].buttons[2].pressed = false;
              }
              break;
            }
            case 32: { // space
              keys.space = false;
              break;
            }
            case 17: { // ctrl
              keys.ctrl = false;
              break;
            }
          }
        /* } else {
          if (focusedTab && focusedTab.iframe) {
            focusedTab.iframe.sendKeyUp(e.which, {
              shiftKey: e.shiftKey,
              ctrlKey: e.ctrlKey,
              altKey: e.altKey,
            });
          }
        } */
      },
      keypress(e) {
        switch (e.which) {
          case 114: {// R
            _endFakeVrDisplay()
              .then(() => _enterXr())
              .catch(err => {
                console.warn(err.stack);
              });
            break;
          }
        }
      },
      /* keypress(e) {
        if (!window.document.pointerLockElement) {
          if (focusedTab) {
            // if (focusedTab === rig.menuMesh.urlMesh) {
            //   rig.menuMesh.urlMesh.handleKey(e.keyCode, e.shiftKey);
            // } else
            if (focusedTab.iframe) {
              focusedTab.iframe.sendKeyPress(e.which, {
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
              });
            }
          }
        }
      }, */
    }, {
      pointerlockchange(e) {
        if (!window.document.pointerLockElement) {
          _bindEventTarget('ui');
        }
      },
    });
  }
};

// mutation observer

/* const observer = new MutationObserver(records => {
  for (let i = 0; i < records.length; i++) {
    const record = records[i];
    const {removedNodes} = record;

    for (let j = 0; j < removedNodes.length; j++) {
      const node = removedNodes[j];

      if (node.tagName === 'IFRAME') {
        const iframe = node;

        if (iframe.destroy) {
          iframe.destroy();
        }

        const tabIndex = tabs.findIndex(tab => tab.iframe === iframe);
        if (tabIndex !== -1) {
          const tab = tabs.splice(tabIndex, 1)[0];
          const {id} = tab;

          if (serverConnectedUrl) {
            const objectMesh = xrmp.getObjectMeshes().find(objectMesh => objectMesh.object.id === id);
            xrmp.removeObjectMesh(objectMesh);
          }
        }
        const layerIndex = layers.indexOf(iframe);
        if (layerIndex !== -1) {
          layers.splice(layerIndex, 1);
        }
      }
    }
  }
});
observer.observe(document.body, {
  childList: true,
}); */

_addScene({
  coords: [
    [0, 0],
  ],
  urls: [{
    url: 'https://google.com',
    mode: '2d',
    coord: [1, 1, -1],
  }],
  color: 0x9ccc65,
});

// controller meshes

/* const controllerGeometry = new THREE.BoxBufferGeometry(0.05, 0.1, 0.01);
const controllerMaterial = new THREE.MeshPhongMaterial({
  color: 0x4caf50,
}); */
const controllerMeshes = Array(2);
for (let i = 0; i < controllerMeshes.length; i++) {
  const controllerMesh = new THREE.Object3D();
  controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 0, -0.1);
  controllerMesh.quaternion.setFromUnitVectors(
    new THREE.Vector3(0, 0, -1),
    new THREE.Vector3(0, -1, -1)
  );

  const rayMesh = (() => {
    const geometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
      .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
    const material = new THREE.MeshBasicMaterial({
      color: RAY_COLOR,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geometry, material);
    // mesh.visible = true;
    mesh.frustumCulled = false;
    return mesh;
  })();
  controllerMesh.add(rayMesh);
  controllerMesh.rayMesh = rayMesh;

  const dotMesh = (() => {
    const geometry = new THREE.SphereBufferGeometry(0.01, 5, 5);
    const material = new THREE.MeshBasicMaterial({
      color: 0xe91e63,
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.z = -1;
    mesh.visible = true;
    return mesh;
  })();
  controllerMesh.add(dotMesh);
  controllerMesh.dotMesh = dotMesh;

  controllerMesh.ray = new THREE.Ray();
  controllerMesh.update = () => {
    controllerMesh.ray.origin.copy(controllerMesh.position);
    controllerMesh.ray.direction
      .set(0, 0, -1)
      .applyQuaternion(controllerMesh.quaternion);
  };

  scene.add(controllerMesh);
  controllerMeshes[i] = controllerMesh;
}
// controllerMeshes[0].add(toolMesh);
const _getControllerIndex = gamepad => gamepad.hand === 'left' ? 0 : 1;

// grid

/* const gridMesh = (() => {
  const topGeometry = new THREE.BoxBufferGeometry(0.01, 1, 0.01);
  const leftGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0))
  ));
  const frontGeometry = topGeometry.clone().applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))
  ));
  const boxGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, 0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, 0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5)),
    topGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0, -0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, -0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0.5)),
    leftGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, -0.5)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    frontGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
  ]);
  const boxGeometries = [];
  for (let x = -8; x <= 8; x++) {
    for (let y = 0; y <= 4; y++) {
      for (let z = -8; z <= 8; z++) {
        boxGeometries.push(boxGeometry.clone().applyMatrix(new THREE.Matrix4().makeTranslation(x, y + 0.5, z)));
      }
    }
  }
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(boxGeometries);
  const gridVsh = `
    varying vec3 vWorldPos;
    // varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vUv = uv;
      vWorldPos = abs(position);
    }
  `;
  const gridFsh = `
    // uniform sampler2D uTex;
    uniform float uTime;
    varying vec3 vWorldPos;
    void main() {
      // float distance = sqrt(vWorldPos.x*vWorldPos.x + vWorldPos.y*vWorldPos.y + vWorldPos.z*vWorldPos.z);
      // float distance2 = uTime - 3.0;
      // float d = abs(distance - distance2);

      float distance2 = uTime - 3.0;
      float d;
      if (vWorldPos.x >= vWorldPos.y && vWorldPos.x >= vWorldPos.z) {
        d = abs(vWorldPos.x - distance2);
      } else if (vWorldPos.y >= vWorldPos.x && vWorldPos.y >= vWorldPos.z) {
        d = abs(vWorldPos.y - distance2);
      } else {
        d = abs(vWorldPos.z - distance2);
      }

      gl_FragColor = vec4(0.11055276381909548, 0.27638190954773867, 0.4103852596314908, 1.0) * (4.0 - pow(d, 3.0)) * 0.5; // 0x42a5f5
      if (gl_FragColor.a >= 1.9) {
        gl_FragColor.rgb *= 3.0;
      } else if (gl_FragColor.a <= 0.1) {
        discard;
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: gridVsh,
    fragmentShader: gridFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(gridMesh); */

const _makeLabelMesh = s => {
  const width = 2;
  const height = 0.2;
  const geometry = new THREE.PlaneBufferGeometry(width, height);
  const labelVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const labelFsh = `
    varying vec2 vUv;
    vec4 color = vec4(${new THREE.Color(0x1976d2).toArray().map(n => n.toFixed(8)).join(',')}, 1.0);
    void main() {
      if ((vUv.x < 0.01 || vUv.x > 0.99) || ((vUv.y < 0.05 || vUv.y > 0.95) && (vUv.x < 0.02 || vUv.x > 0.98))) {
        // gl_FragColor = vec4(vec3(0.11055276381909548, 0.27638190954773867, 0.4103852596314908) * 2.0, 1.0);
        gl_FragColor = color;
      } else {
        gl_FragColor = vec4(vUv.x, vUv.y, 0.0, 0.5);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: labelVsh,
    fragmentShader: labelFsh,
    transparent: true,
    side: THREE.DoubleSide,
    // depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.width = width;
  mesh.height = height;
  mesh.frustumCulled = false;
  mesh.getGlyphs = () => {
    const glyphs = textMesh.geometry.layout.glyphs.slice();
    if (glyphs.length > 0) {
      const lastGlyph = glyphs[glyphs.length - 1];
      glyphs.push({x: lastGlyph.x + lastGlyph.data.width});
    }
    return glyphs;
  };
  mesh.plane = new THREE.Plane();
  mesh.leftLine = new THREE.Line3();
  mesh.topLine = new THREE.Line3();
  mesh.update = () => {
    const menuWorldWidth = width;
    const menuWorldHeight = height;
    mesh.leftLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.leftLine.end
      .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.topLine.start
      .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
      .applyMatrix4(mesh.matrixWorld);
    mesh.topLine.end
      .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
      .applyMatrix4(mesh.matrixWorld);

    mesh.plane.setFromCoplanarPoints(
      mesh.leftLine.start,
      mesh.leftLine.end,
      mesh.topLine.end
    );
  };
  mesh.intersect = ray => {
    const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
    if (intersectionPoint) {
      const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
      const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

      const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / mesh.width;
      const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / mesh.height;
      const distance = ray.origin.distanceTo(intersectionPoint);

      if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
        const xScale = mesh.width / mesh.textMesh.scale.x;
        const x = xFactor * xScale;
        const yScale = mesh.height;
        const y = yFactor * yScale;
        return {
          type: 'label',
          mesh,
          distance,
          cancel: true,
          x,
          y,
          xScale,
          yScale,
        };
      }
    }
    return null;
  };

  const textMesh = _makeTextMesh(s);
  textMesh.position.x -= width/2;
  // textMesh.position.x += -0.45;
  textMesh.position.y += 0.02;
  textMesh.position.z += 0.001;
  mesh.add(textMesh);
  mesh.textMesh = textMesh;

  const caretMesh = _makeCaretMesh(mesh);
  mesh.add(caretMesh);
  mesh.caretMesh = caretMesh;

  return mesh;
};

const _makeMoveMesh = (() => {
  const material = new THREE.MeshBasicMaterial({
    color: new THREE.Color(0x333333),
  });

  const cornerGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.2, 0.03, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
  ]);
  const browserTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    cornerGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
  ]);
  const _makeBrowserMesh = () => {
    const mesh = new THREE.Mesh(browserTargetGeometry, material);
    mesh.frustumCulled = false;
    return mesh;
  }

  const edgeGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const portalTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 1)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0)),
    edgeGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 1)),
  ]);
  const volumeTargetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    portalTargetGeometry
      .clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5)),
    new THREE.BoxBufferGeometry(0.2, 0.03, 0.03),
    new THREE.BoxBufferGeometry(0.03, 0.1, 0.03).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.1/2, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.03, 0.1).applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.1/2)),
  ])
  const _makeVolumeMesh = () => {
    const mesh = new THREE.Mesh(volumeTargetGeometry, material);
    mesh.frustumCulled = false;
    return mesh;
  };

  return type => {
    switch (type) {
      case 'browser': return _makeBrowserMesh();
      case 'volume': return _makeVolumeMesh();
      default: return null;
    }
  };
})();

const trayMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(2, 0.3)
    .applyMatrix(localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), -Math.PI/2)));
  const material = new THREE.MeshBasicMaterial({
    color: 0x333333,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position
    .copy(camera.position)
    .add(new THREE.Vector3(0, -0.5, -1 + 0.2/2));
  mesh.frustumCulled = false;

  const _makeIframe = (url, type) => {
    const iframe = document.createElement('iframe');
    iframe.addEventListener('load', () => {
      console.log(`iframe loaded: ${type} ${iframe.src}`);
    });
    iframe.addEventListener('error', err => {
      console.log(`iframe load error: ${type} ${iframe.src} ${err.stack}`);
    });
    iframe.d = type === 'browser' ? 2 : 3;
    iframe.src = url;
    return iframe;
  };
  const _makeIconMesh = (url, img, type, onclick, oncrosshair, onclose, pagable) => {
    const iconSize = 0.2;
    const subIconSize = 0.4;
    const geometry = new THREE.PlaneBufferGeometry(iconSize, iconSize);
    const texture = new THREE.Texture(img);
    if (img) {
      texture.needsUpdate = true;
    }
    const iconVsh = `
      uniform float uTime;
      varying vec2 vUv;
      const float PI = 3.1415926535897932384626433832795;
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position + vec3(0., sin(pow(uTime, 0.5) * PI) * 0.1, 0.), 1.);
        vUv = uv;
      }
    `;
    const iconFsh = `
      uniform sampler2D uTex;
      uniform vec3 uColor;
      uniform float uTime;
      varying vec2 vUv;
      void main() {
        gl_FragColor = texture2D(uTex, vUv);
        if (gl_FragColor.a >= 0.01) {
          gl_FragColor.rgb += uColor;
          if (uColor.r > 0. || uColor.g > 0. || uColor.b > 0.) {
            gl_FragColor.rgb += (1.0 - pow(uTime, 0.5)) * 0.8;
          }
        } else {
          discard;
        }
      }
    `;
    const color = 0x66bb6a;
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTex: {
          type: 't',
          value: texture,
        },
        uColor: {
          type: 'c',
          value: new THREE.Color(0),
        },
        uTime: {
          type: 'f',
          value: 0,
        },
      },
      vertexShader: iconVsh,
      fragmentShader: iconFsh,
      side: THREE.DoubleSide,
      transparent: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.frustumCulled = false;
    mesh.localVisible = true;

    if (url && type) {
      const iframe = _makeIframe(url, type);

      if (type === 'browser' || type === 'volume') {
        layers.push(iframe);
        iframe.destroy = (destroy => function() {
          layers.splice(layers.indexOf(iframe), 1);
          return destroy.apply(this, arguments);
        })(iframe.destroy);
        mesh.iframe = iframe;

        const moveMesh = _makeMoveMesh(type);
        scene.add(moveMesh);
        mesh.moveMesh = moveMesh;
      } else {
        throw new Error(`unknown iframe type ${type}`);
      }
    } else {
      mesh.iframe = null;
    }
    if (type) {
      const material2 = material.clone();
      const typeImg = (() => {
        switch (type) {
          case 'browser': return browserImg;
          case 'volume': return diceImg;
          default: return null;
        }
      })();
      const texture = new THREE.Texture(typeImg);
      texture.needsUpdate = true;
      material2.uniforms.uTex.value = texture;
      const typeMesh = new THREE.Mesh(geometry, material2);
      typeMesh.frustumCulled = false;
      typeMesh.position.set(-0.15, 0.15, 0);
      typeMesh.scale.set(subIconSize, subIconSize, subIconSize);
      mesh.add(typeMesh);
      mesh.typeMesh = typeMesh;
    }
    if (oncrosshair) {
      const material2 = material.clone();
      const texture = new THREE.Texture(crosshairImg);
      texture.needsUpdate = true;
      material2.uniforms.uTex.value = texture;
      const crosshairMesh = new THREE.Mesh(geometry, material2);
      crosshairMesh.visible = false;
      crosshairMesh.frustumCulled = false;
      crosshairMesh.position.set(0, 0.15, 0);
      crosshairMesh.scale.set(subIconSize, subIconSize, subIconSize);
      mesh.add(crosshairMesh);
      mesh.crosshairMesh = crosshairMesh;
    }
    if (onclose) {
      const material2 = material.clone();
      const texture = new THREE.Texture(timesImg);
      texture.needsUpdate = true;
      material2.uniforms.uTex.value = texture;
      const closeMesh = new THREE.Mesh(geometry, material2);
      closeMesh.visible = false;
      closeMesh.frustumCulled = false;
      closeMesh.position.set(0.15, 0.15, 0);
      closeMesh.scale.set(subIconSize, subIconSize, subIconSize);
      mesh.add(closeMesh);
      mesh.closeMesh = closeMesh;
    }

    mesh.url = url;
    mesh.type = type;
    mesh.x = 0;
    mesh.y = 0;
    mesh.setUrl = s => {
      mesh.url = s;
      mesh.iframe.src = s;
    };
    mesh.setPosition = (newX, newY) => {
      mesh.x = newX;
      mesh.y = newY;
    };
    mesh.update = page => {
      const _select = () => {
        mesh.material.uniforms.uColor.value = new THREE.Color(0x9ccc65);
        mesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;

        if (mesh.typeMesh) {
          mesh.typeMesh.visible = true;
        }
        if (mesh.crosshairMesh) {
          mesh.crosshairMesh.visible = true;
        }
        if (mesh.closeMesh) {
          mesh.closeMesh.visible = true;
        }
      };
      const _unselect = () => {
        mesh.material.uniforms.uColor.value = new THREE.Color(0);
        mesh.material.uniforms.uTime.value = 0;

        if (mesh.typeMesh) {
          mesh.typeMesh.visible = false;
        }
        if (mesh.crosshairMesh) {
          mesh.crosshairMesh.visible = false;
        }
        if (mesh.closeMesh) {
          mesh.closeMesh.visible = false;
        }
      };
      if (mesh.parent === selectedIconMesh) {
        let {x, y} = mesh;
        if (pagable) {
          x += 5 * page;

          mesh.visible = x >= 0 && x < 5;
        } else {
          mesh.visible = mesh.localVisible;
        }

        if (mesh.visible) {
          mesh.position.set(-0.8 + x * 0.4, 0.1 + y * 0.3, 0);

          if (mesh.x === selectedIconCoord.x && mesh.y === selectedIconCoord.y) {
            _select();
          } else {
            _unselect();
          }
        }
      } else {
        mesh.visible = false;
      }
    };
    mesh.intersect = ray => {
      if (mesh.visible && img) {
        localMatrix.compose(
          ray.origin,
          localQuaternion.setFromUnitVectors(localVector.set(0, 0, -1), ray.direction),
          localVector2.set(1, 1, 1)
        ).premultiply(
          localMatrix2
            .copy(mesh.matrixWorld)
            .getInverse(localMatrix2)
        ).decompose(localRay.origin, localQuaternion, localVector);
        localRay.direction.set(0, 0, -1).applyQuaternion(localQuaternion);

        if (mesh.crosshairMesh && mesh.crosshairMesh.visible) {
          const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(mesh.crosshairMesh.position, localVector.copy(mesh.crosshairMesh.scale).multiplyScalar(iconSize)), localVector);
          if (intersectionPoint) {
            return {
              type: 'icon-crosshair',
              distance: localRay.origin.distanceTo(intersectionPoint),
              cancel: true,
              oncrosshair,
            };
          }
        }

        if (mesh.closeMesh && mesh.closeMesh.visible) {
          const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(mesh.closeMesh.position, localVector.copy(mesh.closeMesh.scale).multiplyScalar(iconSize)), localVector);
          if (intersectionPoint) {
            return {
              type: 'icon-close',
              distance: localRay.origin.distanceTo(intersectionPoint),
              cancel: true,
              onclose,
            };
          }
        }

        const intersectionPoint = localRay.intersectBox(localBox.setFromCenterAndSize(localVector.set(0, 0, 0), localVector2.set(0.2, 0.2, 0.2)), localVector);
        if (intersectionPoint) {
          return {
            type: 'icon',
            distance: localRay.origin.distanceTo(intersectionPoint),
            cancel: true,
            onclick,
          };
        }

        return null;
      } else {
        return null;
      }
    };
    mesh.destroy = () => {
      mesh.iframe && mesh.iframe.destroy();
    };
    return mesh;
  };
  const _makeAndAddIconMesh = (url, img, type, x, y, onclick, oncrosshair, onclose, pagable, parentMesh) => {
    const iconMesh = _makeIconMesh(url, img, type, onclick, oncrosshair, onclose, pagable);
    iconMesh.setPosition(x, y);
    parentMesh.add(iconMesh);
    return iconMesh;
  };

  const actionIconMeshes = new THREE.Object3D();
  [
    [layersImg, 0, 0, () => {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === 0 && iconMesh.y === 0);
      if (iconMesh) {
        selectedIconMesh = appIconMeshes;
        selectedIconCoord.set(0, 0);
        selectedIconPage = 0;

        labelMesh.textMesh.setText(iconMesh.url);
      }
    }],
    [browserImg, 1, 0, () => {
      selectedIconCoord.set(1, 0);
      labelMesh.textMesh.setText('https://google.com');
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
    [diceImg, 2, 0, () => {
      selectedIconCoord.set(2, 0);
      labelMesh.textMesh.setText('https://rawcdn.githack.com/exokitxr/webxr-samples/a8e2c94eba0ee5c9215f20d13057b6c25675d9b0/xr-presentation.html');
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
    [mapImg, 3, 0, () => {
      selectedIconCoord.set(3, 0);
      labelMesh.visible = false;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = false;
      mapMesh.localVisible = true;
    }],
    [cogsImg, 4, 0, () => {
      selectedIconMesh = settingsIconMeshes;
      // selectedIconCoord.set(-1, 1);
      selectedIconCoord.set(0, 0);
    }],
    [plusImg, 5, 1, i => {
      let type = null;
      switch (selectedIconCoord.x) {
        case 1: {
          type = 'browser';
          break;
        }
        case 2: {
          type = 'volume';
          break;
        }
      }
      _addAppIconMesh(labelMesh.textMesh.getText(), faviconImg, type, i);
    }],
  ].forEach(([img, x, y, onclick]) => _makeAndAddIconMesh(null, img, null, x, y, onclick, null, null, false, actionIconMeshes));
  mesh.add(actionIconMeshes);

  const appIconMeshes = new THREE.Object3D();
  [
    [arrowLeftImg, -1, 1, () => {
      selectedIconMesh = actionIconMeshes;
      selectedIconCoord.set(1, 0);
      selectedIconPage = 0;
      
      labelMesh.textMesh.setText(DEFAULT_URL);
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
    [chevronLeftImg, -1, 0, () => {
      selectedIconPage = Math.max(selectedIconPage - 1, 0);
    }],
    [chevronRightImg, 5, 0, () => {
      selectedIconPage++;
    }],
    [locationImg, 5, 1, () => {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y);
      const url = labelMesh.textMesh.getText();
      iconMesh.setUrl(url);
    }],
  ].forEach(([img, x, y, onclick]) => _makeAndAddIconMesh(null, img, null, x, y, onclick, null, null, false, appIconMeshes));
  mesh.add(appIconMeshes);
  mesh.appIconMeshes = appIconMeshes;

  const _addAppIconMesh = (url, img, type, i) => {
    for (let x = 0;; x++) {
      if (appIconMeshes.children.findIndex(mesh => mesh.x === x) === -1) {
        const y = 0;
        const iconMesh = _makeAndAddIconMesh(url, img, type, x, y, () => {
          selectedIconCoord.set(iconMesh.x, iconMesh.y);
          labelMesh.textMesh.setText(iconMesh.url);
        }, i => {
          _moveApp(iconMesh, i);
        }, () => { 
          const index = appIconMeshes.children.indexOf(iconMesh);
          for (let i = index; i < appIconMeshes.children.length; i++) {
            const child = appIconMeshes.children[i];
            child.setPosition(child.x - 1, child.y);
          }
          appIconMeshes.remove(iconMesh);
          iconMesh.destroy();
          
          if (appIconMeshes.children.some(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y)) {
            // nothing
          } else {
            if (appIconMeshes.children.some(iconMesh => iconMesh.x === 0 && iconMesh.y === 0)) {
              selectedIconCoord.set(0, 0);
            } else {
              selectedIconMesh = actionIconMeshes;
              selectedIconCoord.set(1, 0);
              selectedIconPage = 0;
              
              labelMesh.textMesh.setText(DEFAULT_URL);
              labelMesh.visible = true;
              actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
              mapMesh.localVisible = false;
            }
          }
        }, true, appIconMeshes);

        selectedIconMesh = appIconMeshes;
        selectedIconCoord.set(x, 0);
        selectedIconPage = 0;

        labelMesh.textMesh.setText(url);

        _moveApp(iconMesh, i);

        break;
      }
    }
  };
  const _moveApp = (iconMesh, i) => {
    moveSpecs[i] = {
      iconMesh,
    };
  };

  const settingsIconMeshes = new THREE.Object3D();
  [
    [arrowLeftImg, -1, 1, () => {
      selectedIconMesh = actionIconMeshes;
      selectedIconCoord.set(1, 0);

      labelMesh.textMesh.setText(DEFAULT_URL);
      labelMesh.visible = true;
      actionIconMeshes.children.find(mesh => mesh.x === 5 && mesh.y === 1).localVisible = true;
      mapMesh.localVisible = false;
    }],
  ].forEach(([img, x, y, onclick]) => _makeAndAddIconMesh(null, img, null, x, y, onclick, null, null, false, settingsIconMeshes));
  mesh.add(settingsIconMeshes);

  let selectedIconMesh = actionIconMeshes;
  let selectedIconCoord = new THREE.Vector2(1, 0);
  let selectedIconPage = 0;

  const labelMesh = _makeLabelMesh(DEFAULT_URL);
  labelMesh.position.y = 0.4;
  mesh.add(labelMesh);
  mesh.labelMesh = labelMesh;

  const mapMesh = (() => {
    const size = 11;
    const scale = 0.04;
    const geometry = new THREE.PlaneBufferGeometry(size, size, size, size)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))));
    const mapVsh = `
      varying vec3 vPosition;
      void main() {
        float radius = sqrt(position.x*position.x + position.z*position.z);
        vec3 p = vec3(position.x, position.y, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
        vPosition = position;
      }
    `;
    const mapFsh = `
      uniform vec2 uSelect;
      varying vec3 vPosition;
      void main() {
        float c;
        if (floor(vPosition.x + 11.0/2.0) == uSelect.x && floor(vPosition.z + 11.0/2.0) == uSelect.y) {
          c = 0.7;
        } else {
          c = 0.5;
        }
        float a;
        vec3 f = fract(vPosition + 0.5);
        if (f.x <= 0.05 || f.x >= 0.95 || f.z <= 0.05 || f.z >= 0.95) {
          a = 0.0;
        } else {
          a = 1.0;
        }
        gl_FragColor = vec4(vec3(c), a);
      }
    `;
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uSelect: {
          type: 'v2',
          value: new THREE.Vector2(),
        },
      },
      vertexShader: mapVsh,
      fragmentShader: mapFsh,
      side: THREE.DoubleSide,
      transparent: true,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.visible = false;
    mesh.frustumCulled = false;
    mesh.width = size*scale;
    mesh.height = size*scale;
    mesh.localVisible = false;
    mesh.plane = new THREE.Plane();
    mesh.leftLine = new THREE.Line3();
    mesh.topLine = new THREE.Line3();
    mesh.update = () => {
      mesh.visible = trayMesh.visible && mesh.localVisible;
      if (mesh.visible) {
        mesh.position.copy(trayMesh.position).add(localVector.set(0, 0.3, 0).applyQuaternion(trayMesh.quaternion));
        mesh.scale.copy(trayMesh.scale).multiplyScalar(scale);
        mesh.updateMatrixWorld();

        const menuWorldWidth = size;
        const menuWorldHeight = size;
        mesh.leftLine.start
          .set(-menuWorldWidth/2, 0, -menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);
        mesh.leftLine.end
          .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);

        mesh.topLine.start
          .set(-menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);
        mesh.topLine.end
          .set(menuWorldWidth/2, 0, menuWorldHeight/2)
          .applyMatrix4(mesh.matrixWorld);

        mesh.plane.setFromCoplanarPoints(
          mesh.leftLine.start,
          mesh.leftLine.end,
          mesh.topLine.end
        );
      }
    };
    mesh.intersect = ray => {
      const intersectionPoint = ray.intersectPlane(mesh.plane, localVector);
      if (intersectionPoint) {
        const leftIntersectionPoint = mesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
        const topIntersectionPoint = mesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

        const xFactor = topIntersectionPoint.distanceTo(mesh.topLine.start) / mesh.width;
        const yFactor = leftIntersectionPoint.distanceTo(mesh.leftLine.start) / mesh.height;
        const distance = ray.origin.distanceTo(intersectionPoint);

        if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
          const xScale = mesh.width;
          const x = Math.floor(xFactor * size);
          const yScale = mesh.height;
          const y = Math.floor(yFactor * size);

          material.uniforms.uSelect.value.set(x, y);

          return {
            type: 'map',
            mesh,
            distance,
            cancel: true,
            x: x - Math.floor(11/2),
            y: y - Math.floor(11/2),
            xScale,
            yScale,
          };
        }
      }
      return null;
    };

    const avatarMesh = (() => {
      const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
        new THREE.CylinderBufferGeometry(0.01, 0.05, 0.2, 3, 1)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.05/2, 0))
          .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
            new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, 0, -1)
            )
          )),
        new THREE.BoxBufferGeometry(0.2, 0.5, 0.1)
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5/2 - 0.1, 0))
      ]).applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, 0));
      const material = new THREE.MeshPhongMaterial({
        color: 0x4caf50,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      return mesh;
    })();
    mesh.add(avatarMesh);

    return mesh;
  })();
  scene.add(mapMesh);
  mesh.mapMesh = mapMesh;
  
  /* labelMesh.textMesh.addEventListener('update', e => {
    const {url} = e;
    if (selectedIconMesh === appIconMeshes) {
      const iconMesh = appIconMeshes.children.find(iconMesh => iconMesh.x === selectedIconCoord.x && iconMesh.y === selectedIconCoord.y);
      iconMesh.setUrl(url);
    }
  }); */

  const keyboardMesh = (() => {
    const object = new THREE.Object3D();

    const planeMesh = (() => {
      const geometry = new THREE.PlaneBufferGeometry(1, keyboardHeight / keyboardWidth);
      const texture = new THREE.Texture(
        keyboardImg,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0.9,
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.frustumCulled = false;
      mesh.position.y = -0.1;
      mesh.position.z = 0.3;
      mesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        new THREE.Vector3(0, 1, 1).normalize()
      );
      mesh.updateMatrixWorld();

      const keyMeshes = [];
      for (let i = 0; i < 2; i++) {
        const keyMesh = (() => {
          const geometry = new THREE.PlaneBufferGeometry(1, 1);
          const texture = new THREE.Texture(
            null,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.NearestFilter,
            THREE.NearestFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            1
          );
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.frustumCulled = false;
          return mesh;
        })();
        mesh.add(keyMesh);

        keyMeshes.push(keyMesh);
      }
      mesh.keyMeshes = keyMeshes;

      return mesh;
    })();
    object.add(planeMesh);
    object.planeMesh = planeMesh;

    object.plane = new THREE.Plane();
    object.leftLine = new THREE.Line3();
    object.topLine = new THREE.Line3();
    object.update = () => {
      object.leftLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.leftLine.end
        .set(-1/2, -keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.topLine.start
        .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);
      object.topLine.end
        .set(1/2, keyboardHeight / keyboardWidth / 2, 0)
        .applyMatrix4(planeMesh.matrixWorld);

      object.plane.setFromCoplanarPoints(
        object.leftLine.start,
        object.leftLine.end,
        object.topLine.end
      );
    };
    object.intersect = (ray, index) => {
      const intersectionPoint = ray.intersectPlane(keyboardMesh.plane, localVector);
      if (intersectionPoint) {
        const leftIntersectionPoint = keyboardMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);
        const topIntersectionPoint = keyboardMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

        const xFactor = topIntersectionPoint.distanceTo(keyboardMesh.topLine.start) / (1);
        const yFactor = leftIntersectionPoint.distanceTo(keyboardMesh.leftLine.start) / (keyboardHeight / keyboardWidth);
        const distance = ray.origin.distanceTo(intersectionPoint);

        if (xFactor > 0 && xFactor < 0.99999 && yFactor > 0 && yFactor < 0.99999 && distance < rayDistance) {
          const x = xFactor * keyboardWidth;
          const y = yFactor * keyboardHeight;
          const keyMesh = planeMesh.keyMeshes[index];

          for (let j = 0; j < keyMap.length; j++) {
            const [key, kx1, ky1, kx2, ky2] = keyMap[j];
            if (x >= kx1 && x < kx2 && y >= ky1 && y < ky2) {
              const width = kx2 - kx1;
              const height = ky2 - ky1;
              let imageData = keyboardHighlightCanvasCtx.getImageData(kx1, ky1, width, height);
              if (key === 'enter') { // special case the enter key; it has a non-rectangular shape
                cacheCanvasCtx.putImageData(imageData, 0, 0);
                cacheCanvasCtx.clearRect(0, 0, 80, 140);

                imageData = cacheCanvasCtx.getImageData(0, 0, imageData.width, imageData.height);
              }

              keyMesh.material.map.image = imageData;
              keyMesh.material.map.needsUpdate = true;

              keyMesh.position
                .set(
                  -1/2 + ((width/2 + kx1) / keyboardWidth),
                  (keyboardHeight / keyboardWidth)/2 - ((height/2 + ky1) / keyboardHeight * (keyboardHeight / keyboardWidth)),
                   0.01 * (1)
                );
              keyMesh.scale.set(
                width / keyboardWidth,
                height / keyboardHeight * (keyboardHeight / keyboardWidth),
                1
              );
              keyMesh.updateMatrixWorld();
              keyMesh.visible = true;

              return {
                type: 'key',
                key,
                distance,
                cancel: true,
              };
            }
          }
        }
      }
    };

    return object;
  })();
  mesh.add(keyboardMesh);

  mesh.update = () => {
    labelMesh.update();
    keyboardMesh.update();
    mapMesh.update();
    [actionIconMeshes, appIconMeshes, settingsIconMeshes].forEach(iconMeshes => {
      for (let i = 0; i < iconMeshes.children.length; i++) {
        iconMeshes.children[i].update(selectedIconPage);
      }
    });
  };
  mesh.getIntersectionCandidates = () => mesh.visible ?
    [labelMesh, keyboardMesh, mapMesh, floorMesh]
      .concat(actionIconMeshes.children)
      .concat(appIconMeshes.children)
      .concat(settingsIconMeshes.children)
      .filter(mesh => mesh.visible)
    : [];

  return mesh;
})();
scene.add(trayMesh);

const _makeRoomMesh = (sx, sy, sz, dx, dy, dz, color) => {
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  /* const uvs = geometry.attributes.uv.array;
  const baseUvs = Float32Array.from(uvs);
  const _updateUvs = () => {
    for (let i = 0; i < uvs.length; i += 2) {
      uvs[i] = baseUvs[i] * s;
      uvs[i+1] = baseUvs[i+1] * s;
    }
    geometry.attributes.uv.needsUpdate = true;
  };
  _updateUvs(); */
  const roomVsh = `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vNormal = normal;
      // vWorldPos = abs(position);
    }
  `;
  const roomFsh = `
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      // vec2 uv = fract(vUv);
      vec2 uv;
      if (vNormal.x != 0.0) {
        uv = fract(vWorldPos.yz + vec2(0.0, 0.5));
      } else if (vNormal.y != 0.0) {
        uv = fract(vWorldPos.xz + 0.5);
      } else /* if (vNormal.z != 0.0) */ {
        uv = fract(vWorldPos.xy + vec2(0.5, 0.0));
      }
      /* float diff = uv.x;
      diff = min(diff, abs(uv.x - 1.0));
      diff = min(diff, uv.y);
      diff = min(diff, abs(uv.y - 1.0));
      if (diff <= 0.01) { */
      if ((uv.x <= 0.01 || uv.x >= 0.99) || (uv.y <= 0.01 || uv.y >= 0.99)) {
        // gl_FragColor = vec4(uColor * (1.0 - min(diff/0.02, 1.0)), 0.5);
        gl_FragColor = vec4(uColor, 0.5);
      // } else if (abs(abs(uv.x - 0.5) - abs(uv.y - 0.5)) <= 0.01) {
      } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5);
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.5);
      }

      gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uHighlight: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    mesh.position.set((sx + dx)/2, (sy + dy)/2 + 0.5, (sz + dz)/2);
    mesh.scale.set(Math.abs(dx - sx) + 1, Math.abs(dy - sy) + 1, Math.abs(dz - sz) + 1);
    mesh.updateMatrixWorld();
  };
  mesh.update();
  mesh.getRange = () => [sx, sy, sz, dx, dy, dz];
  mesh.getCenter = () => [(sx+dx)/2 + 0.5, (sy+dy)/2 + 0.5, (sz+dz)/2 + 0.5];
  mesh.classify = () => {
    const wx = Math.abs(dx - sx) + 1;
    const wy = Math.abs(dy - sy) + 1;
    const wz = Math.abs(dz - sz) + 1;
    if (wx === 1 && wy === 1 && wz === 1) {
      return 'point';
    } else if (wx === 1 && wy === 2 && wz === 1) {
      return 'portal';
    } else {
      const sortedDimensions = [wx, wy, wz].sort((a, b) => a - b);
      if (sortedDimensions[0] === 1 && sortedDimensions[1] > 1 && sortedDimensions[2] > 1) {
        return 'plane';
      } else {
        return 'volume';
      }
    }
  };
  mesh.setEnd = (newDx, newDy, newDz) => {
    dx = newDx;
    dy = newDy;
    dz = newDz;

    mesh.update();
  };
  mesh.setColor = c => {
    mesh.material.uniforms.uColor.value.setHex(c);
  };
  mesh.setHighlight = highlight => {
    mesh.material.uniforms.uHighlight.value = highlight ? 0.2 : 0;
  };
  mesh.contains = position => {
    const box = new THREE.Box3();
    box.expandByPoint(new THREE.Vector3(sx, sy, sz));
    box.expandByPoint(new THREE.Vector3(dx, dy, dz));
    return box.containsPoint(position);
  };
  return mesh;
};
const _makePointMesh = (sx, sy, sz, ox, oy, oz, ow) => {
  const geometry = new THREE.BoxBufferGeometry(0.05, 0.05, 0.05);
  const pointVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const pointFsh = `
    varying vec2 vUv;
    vec3 color = vec3(${new THREE.Color(0xb71c1c).toArray().map(n => n.toFixed(8)).join(',')});
    void main() {
      if ((vUv.x <= 0.01 || vUv.x >= 0.99) || (vUv.y <= 0.01 || vUv.y >= 0.99)) {
        gl_FragColor = vec4(color, 0.5);
      /* } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5); */
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.3);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: pointVsh,
    fragmentShader: pointFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(sx, sy, sz);
  mesh.quaternion.set(ox, oy, oz, ow);
  mesh.frustumCulled = false;
  mesh.setEnd = (sx, sy, sz, ox, oy, oz, ow) => {
    mesh.position.set(sx, sy, sz);
    mesh.quaternion.set(ox, oy, oz, ow);
  };
  mesh.getCenter = () => mesh.position.toArray();
  /* mesh.intersect = ray => {
    localMatrix.compose(
      ray.origin,
      localQuaternion.setFromUnitVectors(localVector.set(0, 0, -1), ray.direction),
      localVector2.set(1, 1, 1)
    ).premultiply(
      localMatrix2
        .copy(mesh.matrixWorld)
        .getInverse(localMatrix2)
    ).decompose(localRay.origin, localQuaternion, localVector);
    localRay.direction.set(0, 0, -1).applyQuaternion(localQuaternion);
    localBox.setFromCenterAndSize(localVector.set(0, 0, 0), localVector2.set(0.1, 0.1, 0.1));

    const intersectionPoint = localRay.intersectBox(localBox, localVector);
    if (intersectionPoint) {
      const distance = localRay.origin.distanceTo(intersectionPoint);
      return {
        type: 'point',
        distance,
      };
    } else {
      return null;
    }
  }; */

  return mesh;
};
const _makeBrowserMesh = (sx, sy, sz, ox, oy, oz, ow, color) => {
  let dx = sx;
  let dy = sy;
  let dz = sz;

  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const browserVsh = `
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vUv = uv;
    }
  `;
  const browserFsh = `
    varying vec2 vUv;
    vec4 color = vec4(${new THREE.Color(0xb71c1c).toArray().map(n => n.toFixed(8)).join(',')}, 0.5);
    void main() {
      if ((vUv.x < 0.01 || vUv.x > 0.99) || (vUv.y < 0.01 || vUv.y > 0.99)) {
        // gl_FragColor = vec4(1.0, 0.792156862745098, 0.1568627450980392, 1.0);
        gl_FragColor = color;
      } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    vertexShader: browserVsh,
    fragmentShader: browserFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  const startPoint = new THREE.Vector3(sx, sy, sz);
  const quaternion = new THREE.Quaternion(ox, oy, oz, ow);
  const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion), startPoint);
  mesh.getCenter = () => mesh.position.toArray();
  mesh.update = () => {
    const endPoint = new THREE.Vector3(dx, dy, dz);
    const upLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion)));
    const rightLine = new THREE.Line3(startPoint, startPoint.clone().add(new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion)));

    endPoint.add(plane.normal.clone().multiplyScalar(-plane.distanceToPoint(endPoint)));
    const midPoint = startPoint.clone().add(endPoint).divideScalar(2);

    const x = rightLine.closestPointToPointParameter(endPoint, false);
    const y = upLine.closestPointToPointParameter(endPoint, false);
    if (x >= -10 && x <= 10 && y >= -10 && y <= 10) {
      mesh.position.copy(midPoint);
      mesh.quaternion.copy(quaternion);
      mesh.scale.set(x, y, 1);
      mesh.updateMatrixWorld();
    }
  };
  mesh.update();
  mesh.setEnd = (newSx, newSy, newSz, newOx, newOy, newOz, newOw) => {
    localRay.set(new THREE.Vector3(newSx, newSy, newSz), new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion(newOx, newOy, newOz, newOw)));
    const intersection = localRay.intersectPlane(plane, new THREE.Vector3());
    if (intersection) {
      dx = intersection.x;
      dy = intersection.y;
      dz = intersection.z;

      mesh.update();
    }
  };
  return mesh;
};
const _makeVolumeMesh = (sx, sy, sz, dx, dy, dz, color) => {
  const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
  const roomVsh = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vPosition = position + 0.5;
      vNormal = normal;
      vUv = uv;
    }
  `;
  const roomFsh = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    uniform vec3 uScale;
    vec4 onColor() {
      return vec4(uColor, 0.5);
    }
    vec4 offColor() {
      if (abs(vUv.x - vUv.y) <= 0.01) {
        return vec4(0.2, 0.2, 0.2, 0.1);
      } else {
        return vec4(0.1, 0.1, 0.1, 0.1);
      }
    }
    void main() {
      vec3 s = vPosition;
      if (vNormal.x != 0.0) {
        if (s.y <= 0.01 || s.y >= 0.99 || s.z <= 0.01 || s.z >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      } else if (vNormal.y != 0.0) {
        if (s.x <= 0.01 || s.x >= 0.99 || s.z <= 0.01 || s.z >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      } else /* if (vNormal.z != 0.0) */ {
        if (s.x <= 0.01 || s.x >= 0.99 || s.y <= 0.01 || s.y >= 0.99) {
          gl_FragColor = onColor();
        } else {
          gl_FragColor = offColor();
        }
      }

      gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uHighlight: {
        type: 'f',
        value: 0,
      },
      uScale: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
    depthWrite: false,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.material.uniforms.uScale.value = mesh.scale;
  mesh.update = () => {
    mesh.position.set((sx + dx)/2, (sy + dy)/2, (sz + dz)/2);
    mesh.scale.set(Math.abs(dx - sx), Math.abs(dy - sy), Math.abs(dz - sz));
    mesh.updateMatrixWorld();
  };
  mesh.update();
  mesh.getRange = () => [sx, sy, sz, dx, dy, dz];
  mesh.getCenter = () => [(sx+dx)/2, (sy+dy)/2, (sz+dz)/2];
  mesh.classify = () => 'volume';
  mesh.setEnd = (newDx, newDy, newDz) => {
    dx = newDx;
    dy = newDy;
    dz = newDz;

    mesh.update();
  };
  /* mesh.setColor = c => {
    mesh.material.uniforms.uColor.value.setHex(c);
  }; */
  mesh.setHighlight = highlight => {
    mesh.material.uniforms.uHighlight.value = highlight ? 0.2 : 0;
  };
  mesh.contains = position => {
    const box = new THREE.Box3();
    box.expandByPoint(new THREE.Vector3(sx, sy, sz));
    box.expandByPoint(new THREE.Vector3(dx, dy, dz));
    return box.containsPoint(position);
  };
  return mesh;
};
const _makeRoomLinkMesh = (index, roomMesh) => {
  const geometry = new THREE.BoxBufferGeometry(0.005, 0.005, 1);
  const positions = geometry.attributes.position.array;
  const uvs = geometry.attributes.uv.array;
  for (let i = 0; i < uvs.length; i += 2) {
    uvs[i+1] = positions[i/2*3 + 2] + 0.5;
  }
  const roomLinkVsh = `
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      // vWorldPos = (modelMatrix * vec4(position, 1.)).xyz;
      vUv = uv;
    }
  `;
  const roomLinkFsh = `
    uniform float uTime;
    uniform float uLength;
    // varying vec3 vWorldPos;
    varying vec2 vUv;
    void main() {
      // float d = sqrt(vWorldPos.x*vWorldPos.x + vWorldPos.y*vWorldPos.y + vWorldPos.z*vWorldPos.z);
      // if (mod(d, 0.1) <= 0.05) {
      if (mod(vUv.y * uLength, 0.1) <= 0.05) {
        // gl_FragColor = vec4(0.1607843137254902, 0.7137254901960784, 0.9647058823529412, 1.0); // 29b6f6
        gl_FragColor = vec4(max(vec3(0.1607843137254902, 0.7137254901960784, 0.9647058823529412) * (1.0 - pow(uTime, 0.5)), vec3(0.2)), 1.0);
        // gl_FragColor = vec4(vec3(max(1.0 - pow(uTime, 0.5), 0.1)), 1.0);
        /* if (gl_FragColor.a <= 0.1) {
          discard;
        } */
      } else {
        discard;
        // gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTime: {
        type: 'f',
        value: 0,
      },
      uLength: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: roomLinkVsh,
    fragmentShader: roomLinkFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.update = () => {
    localVector
      .copy(trayMesh.position)
      .add(localVector2.set(-0.8 + index * 0.4, 0.1, 0).applyQuaternion(trayMesh.quaternion));
    const [cx, cy, cz] = roomMesh.getCenter();
    localVector2.set(cx, cy, cz);

    mesh.position
      .copy(localVector)
      .add(localVector2)
      .divideScalar(2);
    mesh.quaternion.setFromUnitVectors(localVector3.set(0, 0, -1), localVector4.copy(localVector2).sub(localVector).normalize());
    const d = localVector.distanceTo(localVector2);
    mesh.scale.set(1, 1, d);
    mesh.material.uniforms.uLength.value = d;
    mesh.updateMatrixWorld();

    mesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;
  };
  mesh.update();
  return mesh;
};
const _makeRoomDiagramMesh = (index, type, label, color) => {
  let wx, wy, wz;
  if (type === 'point') {
    wx = 1;
    wy = 1;
    wz = 1;
  } else if (type === 'portal') {
    wx = 1;
    wy = 2;
    wz = 1;
  } else if (type === 'plane') {
    wx = 2;
    wy = 2;
    wz = 1;
  } else /* if (type === 'volume') */ {
    wx = 2;
    wy = 2;
    wz = 2;
  }
  const geometry = new THREE.BoxBufferGeometry(0.1*wx, 0.1*wy, 0.1*wz, wx, wy, wz)
    .applyMatrix(localMatrix.makeTranslation(0.1*wx/2, 0.1*wy/2, 0.1*wz/2));
  /* const uvs = geometry.attributes.uv.array;
  const baseUvs = Float32Array.from(uvs);
  const _updateUvs = () => {
    for (let i = 0; i < uvs.length; i += 2) {
      uvs[i] = baseUvs[i] * s;
      uvs[i+1] = baseUvs[i+1] * s;
    }
    geometry.attributes.uv.needsUpdate = true;
  };
  _updateUvs(); */
  const roomVsh = `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vWorldPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
      vNormal = normal;
    }
  `;
  const roomFsh = `
    // uniform sampler2D uTex;
    uniform vec3 uColor;
    uniform float uHighlight;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      // vec2 uv = fract(vUv);
      vec2 uv;
      if (vNormal.x != 0.0) {
        uv = fract(vWorldPos.yz/0.1);
      } else if (vNormal.y != 0.0) {
        uv = fract(vWorldPos.xz/0.1);
      } else /* if (vNormal.z != 0.0) */ {
        uv = fract(vWorldPos.xy/0.1);
      }
      if ((uv.x <= 0.01 || uv.x >= 0.99) || (uv.y <= 0.01 || uv.y >= 0.99)) {
        gl_FragColor = vec4(uColor, 0.5);
      } else if (abs(uv.x - uv.y) <= 0.01) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, 0.5);
      } else {
        gl_FragColor = vec4(0.1, 0.1, 0.1, 0.5);
      }

      // gl_FragColor.rgb += uHighlight;
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      /* uHighlight: {
        type: 'f',
        value: 0,
      }, */
    },
    vertexShader: roomVsh,
    fragmentShader: roomFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });

  const mesh = new THREE.Object3D();
  mesh.label = label;
  mesh.update = () => {
    mesh.position
      .copy(trayMesh.position)
      .add(localVector.set(-0.8 + index * 0.4, 0.1, 0).applyQuaternion(trayMesh.quaternion));
    mesh.rotation.y += 0.01;
    mesh.updateMatrixWorld();
  };
  mesh.update();

  const innerMesh = new THREE.Mesh(geometry, material);
  innerMesh.position.set(-0.1*wx/2, -0.1*wy/2, -0.1*wz/2);
  innerMesh.frustumCulled = false;
  mesh.add(innerMesh);

  return mesh;
};

const portalVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const portalFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 projectionMatrix;
  float checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) - uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer, mat4 projectionMatrixInverse) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(projectionMatrixInverse[0][0], projectionMatrixInverse[1][1]) * clip_space_position.xy,
      -1.0,
      projectionMatrixInverse[2][3] * clip_space_position.z + projectionMatrixInverse[3][3]);
    return view_position;
  }
  mat4 inverse(mat4 m) {
    float
        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    return mat4(
        a11 * b11 - a12 * b10 + a13 * b09,
        a02 * b10 - a01 * b11 - a03 * b09,
        a31 * b05 - a32 * b04 + a33 * b03,
        a22 * b04 - a21 * b05 - a23 * b03,
        a12 * b08 - a10 * b11 - a13 * b07,
        a00 * b11 - a02 * b08 + a03 * b07,
        a32 * b02 - a30 * b05 - a33 * b01,
        a20 * b05 - a22 * b02 + a23 * b01,
        a10 * b10 - a11 * b08 + a13 * b06,
        a01 * b08 - a00 * b10 - a03 * b06,
        a30 * b04 - a31 * b02 + a33 * b00,
        a21 * b02 - a20 * b04 - a23 * b00,
        a11 * b07 - a10 * b09 - a12 * b06,
        a00 * b09 - a01 * b07 + a02 * b06,
        a31 * b01 - a30 * b03 - a32 * b00,
        a20 * b03 - a21 * b01 + a22 * b00) / det;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  /* vec2 ndc = (texCoordFull * 2.0) - 1.0;
  float z_n = 2.0 * z_b - 1.0;
  float zNear = projectionMatrix[3][2] / (projectionMatrix[2][2] - 1.0);
  float zFar = projectionMatrix[3][2] / (projectionMatrix[2][2] + 1.0);
  float z_e = 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear)); */
  mat4 viewMatrixInverse = inverse(viewMatrix);
  mat4 projectionMatrixInverse = inverse(projectionMatrix);
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    // gl_FragColor = vec4(texCoord, 0., 1.);
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    vec4 worldPos = calculate_view_position(texCoordFull, z_b, projectionMatrixInverse);
    worldPos /= worldPos.w;
    worldPos = viewMatrixInverse * worldPos;

    // float p = checkPlane(worldPos, uPlane);
    // if (p >= 0.0) {
      gl_FragColor = texture2D(uTex, texCoord);
      gl_FragDepth = min(gl_FragCoord.z, z_b);
    /* } else {
      if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z;
    } */
    
    gl_FragColor.rgb += vec3(texCoordFull, 1.0) * 0.2;
  }
`;

const volumeVsh = `
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    // vUv = uv;
    vWorldPos = position;
  }
`;
const volumeFsh = `
  uniform sampler2D uTex;
  uniform sampler2D uDepthTex;
  uniform vec2 uViewport;
  uniform sampler2D uXTex;
  uniform vec4 uPlane0;
  uniform vec4 uPlane1;
  uniform vec4 uPlane2;
  uniform vec4 uPlane3;
  uniform vec4 uPlane4;
  uniform vec4 uPlane5;
  varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform mat4 projectionMatrix;
  bool checkPlane(vec4 worldPos, vec4 uPlane) {
    return dot(worldPos.xyz, uPlane.xyz) >= uPlane.w;
  }
  // from https://gamedev.stackexchange.com/questions/108856/fast-position-reconstruction-from-depth/111885#111885
  vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer, mat4 projectionMatrixInverse) {
    vec3 clip_space_position = vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - vec3(1.0);
    vec4 view_position = vec4(vec2(pmi[0][0], pmi[1][1]) * clip_space_position.xy,
      -1.0,
      pmi[2][3] * clip_space_position.z + pmi[3][3]);
    return view_position;
  }
  mat4 inverse(mat4 m) {
    float
        a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
        a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
        a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
        a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    return mat4(
        a11 * b11 - a12 * b10 + a13 * b09,
        a02 * b10 - a01 * b11 - a03 * b09,
        a31 * b05 - a32 * b04 + a33 * b03,
        a22 * b04 - a21 * b05 - a23 * b03,
        a12 * b08 - a10 * b11 - a13 * b07,
        a00 * b11 - a02 * b08 + a03 * b07,
        a32 * b02 - a30 * b05 - a33 * b01,
        a20 * b05 - a22 * b02 + a23 * b01,
        a10 * b10 - a11 * b08 + a13 * b06,
        a01 * b08 - a00 * b10 - a03 * b06,
        a30 * b04 - a31 * b02 + a33 * b00,
        a21 * b02 - a20 * b04 - a23 * b00,
        a11 * b07 - a10 * b09 - a12 * b06,
        a00 * b09 - a01 * b07 + a02 * b06,
        a31 * b01 - a30 * b03 - a32 * b00,
        a20 * b03 - a21 * b01 + a22 * b00) / det;
  }
  /* vec4 calculate_view_position(vec2 texture_coordinate, float depth_from_depth_buffer) {
    return pmi * vec4(vec3(texture_coordinate, depth_from_depth_buffer) * 2.0 - 1.0, 1.0);
  } */
  mat4 viewMatrixInverse = inverse(viewMatrix);
  mat4 projectionMatrixInverse = inverse(projectionMatrix);
  void main() {
    vec2 texCoord = gl_FragCoord.xy / uViewport;
    vec2 texCoordFull = vec2(mod(texCoord.x, 0.5) * 2.0, texCoord.y);
    float z_b = texture2D(uDepthTex, texCoord).r;

    vec4 worldPos = calculate_view_position(texCoordFull, z_b, projectionMatrixInverse);
    worldPos /= worldPos.w;
    worldPos = viewMatrixInverse * worldPos;

    vec4 c = texture2D(uTex, texCoord);

    if (
      c.a == 0.0 || (
        checkPlane(worldPos, uPlane0) &&
        checkPlane(worldPos, uPlane1) &&
        checkPlane(worldPos, uPlane2) &&
        checkPlane(worldPos, uPlane3) &&
        checkPlane(worldPos, uPlane4) &&
        checkPlane(worldPos, uPlane5)
      )
    ) {
      gl_FragColor = c;
      gl_FragDepth = z_b;
    } else {
      discard;
      /* if (p >= -0.05) {
        gl_FragColor = texture2D(uXTex, vec2(0., 0.));
      } else {
        gl_FragColor = texture2D(uXTex, vWorldPos.xy * 10.0);
      }
      gl_FragDepth = gl_FragCoord.z; */
    }
  }
`;

const volumeGeometry = (() => {
  const g = new THREE.BoxBufferGeometry(1, 1, 1).toNonIndexed();
  const geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(g.attributes.position.array, 3));
  return geometry;
})();
const _makeContentMesh = (position, quaternion, scale, iframe) => {
  const geometry = volumeGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uTex: {
        type: 't',
        value: null,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
      uViewport: {
        type: 'v2',
        value: new THREE.Vector2(),
      },
      uXTex: {
        type: 't',
        value: null,
      },
      uPlane0: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane1: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane2: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane3: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane4: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uPlane5: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
    },
    vertexShader: volumeVsh,
    fragmentShader: volumeFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const image = new Image();
  image.src = 'x.png';
  image.onload = () => {
    mesh.material.uniforms.uXTex.value = new THREE.Texture(
      image,
      THREE.UVMapping,
      THREE.RepeatWrapping,
      THREE.RepeatWrapping,
      THREE.LinearFilter,
      THREE.LinearFilter,
      THREE.RGBAFormat,
      THREE.UnsignedByteType,
      16
    );
    mesh.material.uniforms.uXTex.value.needsUpdate = true;
  };
  image.onerror = err => {
    console.warn('fail', err.stack);
  };
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(position);
  mesh.quaternion.copy(quaternion);
  mesh.scale.copy(scale);
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, -scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane0.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, -1, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, scale.y/2, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane1.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(-scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane2.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(-1, 0, 0).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(scale.x/2, 0, 0).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane3.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, -scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane4.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  {
    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
      new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion),
      position.clone().add(new THREE.Vector3(0, 0, scale.z/2).applyQuaternion(quaternion))
    );
    mesh.material.uniforms.uPlane5.value.set(plane.normal.x, plane.normal.y, plane.normal.z, -plane.constant);
  }
  mesh.iframe = iframe;
  return mesh;
};

const cacheCanvas = document.createElement('canvas');
cacheCanvas.width = 1024;
cacheCanvas.height = 1024;
const cacheCanvasCtx = cacheCanvas.getContext('2d');

// box meshes

const boxMeshes = [
  _makeBoxMesh(),
  _makeBoxMesh(),
];
boxMeshes.forEach(boxMesh => {
  scene.add(boxMesh);
});

const moves = [null, null];
const keys = {
  up: false,
  down: false,
  left: false,
  right: false,
};
const _makeButtons = () => ({
  trigger: false,
  grip: false,
  menu: false,
});
const lastButtons = [
  _makeButtons(),
  _makeButtons(),
];
const intersectionSpecs = [
  null,
  null,
];
const moveSpecs = [
  null,
  null,
];

const _handleDefaultKey = (code, shiftKey) => {
  let c = String.fromCharCode(code);
  if (!shiftKey) {
    c = c.toLowerCase();
  }
  _handleSingleKey(c);
};
const _handleSingleKey = c => {
  const s = keyboardFocus.textMesh.getText();
  const index = keyboardFocus.caretMesh.getValue();
  keyboardFocus.textMesh.setText(s.slice(0, index) + c + s.slice(index));
  keyboardFocus.caretMesh.setValue(index + 1);
};
const _handleKey = (code, shiftKey) => {
  // console.log('handle key', code, shiftKey);
  const s = keyboardFocus.textMesh.getText();
  const index = keyboardFocus.caretMesh.getValue();

  if (code === 8) { // backspace
    if (index > 0) {
      keyboardFocus.textMesh.setText(s.slice(0, index - 1) + s.slice(index));
      keyboardFocus.caretMesh.setValue(index - 1);
    } else {
      /* if (s.length === 0) {
        _closeRig();
      } */
    }
  } else if (code === 46) { // delete
    if (index < s.length) {
      keyboardFocus.textMesh.setText(s.slice(0, index) + s.slice(index + 1));
    }
  } else if (code === 32) { // space
    keyboardFocus.textMesh.setText(s.slice(0, index) + ' ' + s.slice(index));
    keyboardFocus.caretMesh.setValue(index + 1);
  } else if (code === 13) { // enter
    console.log('enter', s);
    /* const u = (optionsMesh.d === 3 && urlMesh.urlState.text === DEFAULT_URL) ? 'realitytab.html?color=29b6f6' : urlMesh.urlState.text;
    const {position, quaternion, scale} = _getFrontOfCamera();
    _openUrl(u, position, quaternion, scale, optionsMesh.d);
    _updateRigLists(); */
  } else if (code === 27) { // esc
    trayMesh.labelMesh.caretMesh.visible = false;
    keyboardFocus = null;
  } else if (
    code === 9 || // tab
    code === 16 || // shift
    code === 17 || // ctrl
    code === 18 || // alt
    code === 20 || // capslock
    code === 91 // win
  ) {
    // nothing
  } else if (code === 37) { // left
    keyboardFocus.caretMesh.setValue(Math.max(index - 1, 0));
  } else if (code === 39) { // right
    keyboardFocus.caretMesh.setValue(Math.min(index + 1, s.length));
  } else if (code === 38) { // up
    // nothing
  } else if (code === 40) { // down
    // nothing
  } else if (code === 190) { // .
    _handleSingleKey('.');
  } else if (code === 188) { // ,
    _handleSingleKey(',');
  } else if (code === 191) { // /
    _handleSingleKey('/');
  } else if (code === 186) { // ;
    _handleSingleKey(';');
  } else if (code === 222) { // ;
    _handleSingleKey('\'');
  } else if (code === 219) { // [
    _handleSingleKey('[');
  } else if (code === 221) { // ]
    _handleSingleKey(']');
  } else if (code === 189) { // -
    _handleSingleKey('-');
  } else if (code === 187) { // =
    _handleSingleKey('=');
  } else if (code === 220) { // \
    _handleSingleKey('\\');
  } else if (code === -1) {
    // nothing
  } else {
    _handleDefaultKey(code, shiftKey);
  }
};

// let renderTarget = null;
const startTime = Date.now();
let lastTime = 0;
function animate(time, frame) {
  /* const gl = renderer.getContext();
  gl.clearColor(1, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT|gl.STENCIL_BUFFER_BIT);
  return; */
  const now = Date.now();
  const timeDiff = now - lastTime;
  const startTimeDiff = now - startTime;

  const gamepads = navigator.getGamepads();
  for (let i = 0; i < gamepads.length && i < 2; i++) {
    const gamepad = gamepads[i];
    const moveTab = moves[i];
    const boxMesh = boxMeshes[i];

    if (moveTab) {
      const {iframe} = moveTab;

      const scrollFactor = scrollFactors[i];
      const scaleFactor = scaleFactors[i];

      localVector.fromArray(gamepad.pose.position);
      localQuaternion.fromArray(gamepad.pose.orientation);
      localVector
        .add(
          localVector2.set(0, 0, -scrollFactor)
            .applyQuaternion(localQuaternion)
        );
      localVector2.set(scaleFactor, scaleFactor, scaleFactor);

      iframe.position = localVector.toArray();
      iframe.orientation = localQuaternion.toArray();
      iframe.scale = localVector2.toArray();

      boxMesh.position.copy(localVector);
      boxMesh.quaternion.copy(localQuaternion);
      boxMesh.scale.copy(localVector2);
      // boxMesh.updateMatrixWorld();
      boxMesh.visible = true;

      if (serverConnectedUrl) {
        const objectMesh = xrmp.getObjectMeshes().find(objectMesh => objectMesh.object.id === moveTab.id);
        const {object} = objectMesh;
        const {objectMatrix} = object;
        localVector.toArray(objectMatrix.position);
        localQuaternion.toArray(objectMatrix.quaternion);
        object.pushUpdate();
      }
    } else {
      boxMesh.visible = false;
    }
  }

  const _updateControllerMeshes = () => {
    // if (renderer.vr.enabled) {
      for (let i = 0; i < controllerMeshes.length; i++) {
        controllerMeshes[i].visible = false;
      }

      for (let i = 0; i < 2; i++) {
        const gamepad = gamepads[i];
        if (gamepad && gamepad.connected) {
          const controllerIndex = _getControllerIndex(gamepad);
          const controllerMesh = controllerMeshes[controllerIndex];
          controllerMesh.position.fromArray(gamepad.pose.position);
          controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
          controllerMesh.updateMatrixWorld(true);
          controllerMesh.visible = true;
        }
      }
    // }
  };
  _updateControllerMeshes();

  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      if (fakeXrDisplay) {
        fakeXrDisplay.position.copy(orbitControls.object.position);
        fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);

        if (window.document.pointerLockElement) {
          fakeXrDisplay.pushUpdate();
        } else {
          fakeXrDisplay.pushHmdUpdate();
          fakeXrDisplay.pushGamepadsUpdate(mouse.position, mouse.quaternion);
        }
      }
    }
  };
  _updateOrbitControls();

  const _updateTrayMesh = () => {
    trayMesh.update();
  };
  _updateTrayMesh();

  const _updateMoves = () => {
    for (let i = 0; i < moveSpecs.length; i++) {
      const moveSpec = moveSpecs[i];
      if (moveSpec) {
        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[i];
        if (gamepad) {
          const {iconMesh} = moveSpec;
          const {type, iframe, moveMesh} = iconMesh;

          localVector.fromArray(gamepad.pose.position);
          localQuaternion.fromArray(gamepad.pose.orientation);
          localRay.set(localVector, localVector2.set(0, 0, -1).applyQuaternion(localQuaternion));
          const intersection = floorMesh.intersect(localRay, i);
          if (intersection) {
            localVector.set(Math.floor(intersection.point.x + 0.5), intersection.point.y + 1, Math.floor(intersection.point.z + 0.5));
            localEuler.setFromQuaternion(localQuaternion, localEuler.order);
            localEuler.x = 0;
            localEuler.z = 0;
            const old = localEuler.y;
            localEuler.y = Math.round((localEuler.y < 0 ? (localEuler.y+Math.PI*2) : localEuler.y) / (Math.PI/2)) * (Math.PI/2);
            localQuaternion.setFromEuler(localEuler);
          } else {
            localVector.fromArray(gamepad.pose.position).add(localVector2.set(0, 0, -3).applyQuaternion(localQuaternion));
          }

          moveMesh.position.copy(localVector);
          moveMesh.quaternion.copy(localQuaternion);
          if (iframe) {
            iframe.position = localVector.toArray();
            iframe.orientation = localQuaternion.toArray();
          }
        }
      }
    }
  };
  _updateMoves();

  const _updateIntersections = () => {
    for (let i = 0; i < 2; i++) {
      const controllerMesh = controllerMeshes[i];
      if (controllerMesh.visible && !pendingRooms[i]) {
        controllerMesh.update();

        const candidates = trayMesh.getIntersectionCandidates();

        const intersections = [];
        for (let j = 0; j < candidates.length; j++) {
          const candidate = candidates[j];
          const intersection = candidate.intersect(controllerMesh.ray, i);
          if (intersection) {
            intersections.push(intersection);
          }
        }
        if (intersections.length > 0) {
          const intersection = intersections.sort((a, b) => a.distance - b.distance)[0];
          intersectionSpecs[i] = intersection;

          controllerMesh.dotMesh.position.z = -intersection.distance;
          controllerMesh.dotMesh.updateMatrixWorld();
          controllerMesh.dotMesh.visible = true;

          controllerMesh.rayMesh.scale.z = intersection.distance;
          controllerMesh.rayMesh.updateMatrixWorld();
        } else {
          controllerMesh.dotMesh.visible = false;

          controllerMesh.rayMesh.scale.z = 1;
          controllerMesh.rayMesh.updateMatrixWorld();

          intersectionSpecs[i] = null;
        }
      }
    }
  };
  _updateIntersections();

  const _handleTrigger = (gamepad, i, pressed, lastPressed) => {
    const start = pressed && !lastPressed;
    const end = lastPressed && !pressed;

    if (pressed && !lastPressed) {
      for (let i = 0; i < roomLabels.length; i++) {
        roomLabels[i].caretMesh.visible = false;
      }
      keyboardFocus = null;
    }

    if (pressed && !lastPressed && moveSpecs[i]) {
      moveSpecs[i] = null;
    } else {
      const intersectionSpec = intersectionSpecs[i];
      if (intersectionSpec) {
        if (pressed && !lastPressed) {
          const {type} = intersectionSpec;

          if (type === 'label') {
            const {mesh} = intersectionSpec;
            const glyphs = mesh.getGlyphs();
            const distanceSpecs = glyphs
              .map((c, i) => ({i, x: c.x, distance: Math.abs(intersectionSpec.x - c.x)}))
              .sort((a, b) => a.distance - b.distance);
            const distanceSpec = distanceSpecs.length > 0 ? distanceSpecs[0] : {i: 0, x: 0};
            mesh.caretMesh.setValue(distanceSpec.i);
            mesh.caretMesh.visible = true;
            keyboardFocus = mesh;
          } else if (type === 'icon') {
            intersectionSpec.onclick(i);
          } else if (type === 'icon-crosshair') {
            intersectionSpec.oncrosshair(i);
          } else if (type === 'icon-close') {
            intersectionSpec.onclose(i);
          } else if (type === 'map') {
            console.log('click map', intersectionSpec.x, intersectionSpec.y);
          } else if (type === 'floor') {
            const x = Math.floor((intersectionSpec.x + 3)/6);
            const y = Math.floor((intersectionSpec.y + 3)/6);
            const gamepads = navigator.getGamepads();
            const _destroySelectedBaseMesh = () => {
              scene.remove(selectedBaseMesh);
              selectedBaseMesh.destroy();
              selectedBaseMesh = null;
            };
            if (selectedBaseMesh && !(gamepads[1] && gamepads[1].buttons[2].pressed)) {
              _destroySelectedBaseMesh();
            }
            if (selectedBaseMesh) {
              if (!selectedBaseMesh.addCoord(x, y)) {
                _destroySelectedBaseMesh();
              }
            } else {
              selectedBaseMesh = _makeBaseMesh({
                coords: [[x, y]],
                color: 0x42a5f5,
              });
              _insertBefore(selectedBaseMesh, floorMesh);
            }
          } else if (type === 'key') {
            const {key} = intersectionSpec;
            console.log(`click key: ${key}`);
          } else {
            console.warn(`unknown intersection type ${type}`);
          }
        }
      } /* else {
        if (window.document.pointerLockElement) {
          if (toolMesh.tool === 'point') {
            if (start) {
              const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
              const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
              const point = _makePointMesh(p.x, p.y, p.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w);
              scene.add(point);
              pointMeshes.push(point);
              pendingRooms[i] = point;
            } else if (end) {
              const point = pendingRooms[i];
              if (point) {
                pendingRooms[i] = null;
                const labelMesh = _makeLabelMesh('https://google.com');
                labelMesh.position.copy(point.position);
                labelMesh.position.y += 0.1;
                labelMesh.rotation.setFromQuaternion(point.quaternion, 'YXZ');
                labelMesh.rotation.x = 0;
                labelMesh.updateMatrixWorld();
                labelMesh.update();
                scene.add(labelMesh);
                roomLabels.push(labelMesh);

                const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, point);
                scene.add(roomLinkMesh);
                roomLinks.push(roomLinkMesh);
              }
            } else {
              const point = pendingRooms[i];
              if (point) {
                const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
                const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
                point.setEnd(p.x, p.y, p.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w);
                // console.log('update room', targetMesh.material.uniforms.worldPos.value.toArray().join(','));
              }
            }
          } else if (toolMesh.tool === 'browser' || toolMesh.tool === 'portal') {
            if (start) {
              const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
              const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
              const browser = _makeBrowserMesh(p.x, p.y, p.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w, 0x9ccc65);
              scene.add(browser);
              // rooms.push(browser);
              pendingRooms[i] = browser;
            } else if (end) {
              const browser = pendingRooms[i];
              if (browser) {
                pendingRooms[i] = null;
                const labelMesh = _makeLabelMesh('https://google.com');
                labelMesh.position.copy(browser.position);
                labelMesh.position.y += 0.1;
                labelMesh.rotation.setFromQuaternion(browser.quaternion, 'YXZ');
                labelMesh.rotation.x = 0;
                labelMesh.updateMatrixWorld();
                labelMesh.update();
                scene.add(labelMesh);
                roomLabels.push(labelMesh);

                const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, browser);
                scene.add(roomLinkMesh);
                roomLinks.push(roomLinkMesh);
              }
            } else {
              const browser = pendingRooms[i];
              if (browser) {
                const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
                browser.setEnd(c.position.x, c.position.y, c.position.z, c.quaternion.x, c.quaternion.y, c.quaternion.z, c.quaternion.w);
                // console.log('update room', targetMesh.material.uniforms.worldPos.value.toArray().join(','));
              }
            }
          } else {
            if (start) {
              const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
              const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
              const room = _makeVolumeMesh(p.x, p.y, p.z, p.x, p.y, p.z, 0x4caf50);
              scene.add(room);
              rooms.push(room);
              pendingRooms[i] = room;
            } else if (end) {
              const room = pendingRooms[i];
              if (room) {
                // room.setColor(0x5c6bc0);
                pendingRooms[i] = null;
                const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, room);
                scene.add(roomLinkMesh);
                roomLinks.push(roomLinkMesh);
                const roomDiagramMesh = _makeRoomDiagramMesh(roomDiagrams.length, room.classify(), 'tutorial.html', 0xffee58);
                scene.add(roomDiagramMesh);
                roomDiagrams.push(roomDiagramMesh);
                _addVolume(room);
                // console.log('end room', room.classify(), targetMesh.material.uniforms.worldPos.value.toArray().join(','));
              }
            } else {
              const room = pendingRooms[i];
              if (room) {
                const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
                const p = c.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(c.quaternion));
                room.setEnd(p.x, p.y, p.z);
                // console.log('update room', targetMesh.material.uniforms.worldPos.value.toArray().join(','));
              }
            }
          }
        }
      } */
    }
  };
  const _makeMenuAnimation = spec => {
    const startTime = Date.now();
    const endTime = startTime + 1000;
    const curve = cubicBezier(0, 1, 0, 1);
    return {
      spec,
      getValue() {
        return Math.min(Math.max(curve((Date.now() - startTime) / (endTime - startTime)), 0), 1);
      },
    };
  };
  const _updateGridControls = () => {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < 2; i++) {
      const gamepad = gamepads[i];

      if (gamepad) {
        const pressed = gamepad.buttons[1].pressed;
        const lastPressed = lastPresseds[i];
        _handleTrigger(gamepad, i, pressed, lastPressed);
        lastPresseds[i] = pressed;

        const menu = gamepad.buttons[5].pressed;
        const lastMenu = lastButtons[i].menu;

        if (menu && !lastMenu) {
          const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
          c.matrixWorld.decompose(localVector, localQuaternion, localVector2);
          localVector.add(localVector2.set(0, -0.5, -1 + 0.2/2).applyQuaternion(localQuaternion));

          if (menuFactor < 0.5) {
            menuAnimation = _makeMenuAnimation({
              start: {
                factor: menuFactor,
                position: localVector.clone(),
                quaternion: localQuaternion.clone(),
                scale: new THREE.Vector3(0.001, 0.001, 0.001),
              },
              end: {
                factor: 1,
                position: localVector.clone(),
                quaternion: localQuaternion.clone(),
                scale: new THREE.Vector3(1, 1, 1),
              },
            });
          } else {
            menuAnimation = _makeMenuAnimation({
              start: {
                factor: menuFactor,
                position: trayMesh.position.clone(),
                quaternion: trayMesh.quaternion.clone(),
                scale: new THREE.Vector3(1, 1, 1),
              },
              end: {
                factor: 0,
                position: trayMesh.position.clone(),
                quaternion: trayMesh.quaternion.clone(),
                scale: new THREE.Vector3(0.001, 0.001, 0.001),
              },
            });
          }
        }
        lastButtons[i].menu = menu;

        if (menuAnimation) {
          const {spec: {start, end}} = menuAnimation;
          const f = menuAnimation.getValue();
          menuFactor = start.factor + (end.factor - start.factor) * f;

          trayMesh.quaternion.copy(start.quaternion).slerp(end.quaternion, f);
          trayMesh.position.copy(start.position).lerp(localVector.copy(end.position), f);
          trayMesh.scale.copy(start.scale).lerp(end.scale, f);
          trayMesh.updateMatrixWorld();
          trayMesh.visible = true;
          for (let i = 0; i < trayMesh.appIconMeshes.children.length; i++) {
            const {moveMesh} = trayMesh.appIconMeshes.children[i];
            if (moveMesh) {
              moveMesh.scale.set(menuFactor, menuFactor, menuFactor);
              moveMesh.updateMatrixWorld();
              moveMesh.visible = true;
            }
          }
          skyboxMesh.material.uniforms.uAnimation.value = menuFactor;
          skyboxMesh.visible = true;
          floorMesh.material.uniforms.uAnimation.value = menuFactor;
          floorMesh.visible = true;
          for (let i = 0; i < guardianMeshes.length; i++) {
            const guardianMesh = guardianMeshes[i];
            guardianMesh.material.uniforms.uAnimation.value = menuFactor;
            guardianMesh.visible = true;
          }
          const localBaseMeshes = baseMeshes.concat(selectedBaseMesh ? [selectedBaseMesh] : []);
          for (let i = 0; i < localBaseMeshes.length; i++) {
            const baseMesh = localBaseMeshes[i];
            baseMesh.material.uniforms.uAnimation.value = menuFactor;
            baseMesh.visible = true;
          }

          if (f >= 1) {
            if (end.factor === 0) {
              trayMesh.visible = false;
              for (let i = 0; i < trayMesh.appIconMeshes.children.length; i++) {
                const {moveMesh} = trayMesh.appIconMeshes.children[i];
                if (moveMesh) {
                  moveMesh.visible = false;
                }
              }
              skyboxMesh.visible = false;
              floorMesh.visible = false;
              for (let i = 0; i < guardianMeshes.length; i++) {
                guardianMeshes[i].visible = false;
              }
              const localBaseMeshes = baseMeshes.concat(selectedBaseMesh ? [selectedBaseMesh] : []);
              for (let i = 0; i < localBaseMeshes.length; i++) {
                localBaseMeshes[i].visible = false;
              }
            }
            menuAnimation = null;
          }
        }
      }
    }
  };
  _updateGridControls();

  const _render = () => {
    const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;

    c.matrixWorld.decompose(pointerMesh.position, localQuaternion, localVector2);
    pointerMesh.position.add(localVector.set(0, 0, -1).applyQuaternion(c.quaternion));
    pointerMesh.rotation.x += 0.1;
    pointerMesh.rotation.z += 0.1;

    // gridMesh.material.uniforms.uTime.value = (gridMesh.material.uniforms.uTime.value + 0.1) % 14;
    /* targetMesh.material.uniforms.uTime.value = (Date.now() % 1000) / 1000;
    c.matrixWorld.decompose(targetMesh.material.uniforms.worldPos.value, localQuaternion, localVector2);
    targetMesh.material.uniforms.worldPos.value
      .add(localVector2.set(0, 0, -3).applyQuaternion(localQuaternion));
    targetMesh.material.uniforms.worldPos.value.x = Math.floor(targetMesh.material.uniforms.worldPos.value.x + 0.5);
    targetMesh.material.uniforms.worldPos.value.y = Math.floor(targetMesh.material.uniforms.worldPos.value.y + 0.5);
    targetMesh.material.uniforms.worldPos.value.z = Math.floor(targetMesh.material.uniforms.worldPos.value.z + 0.5); */
    for (let i = 0; i < roomLinks.length; i++) {
      roomLinks[i].update();
    }
    for (let i = 0; i < roomDiagrams.length; i++) {
      roomDiagrams[i].update();
    }

    renderer.render(scene, c);
  };
  _render();

  const _updateMovement = () => {
    if (fakeXrDisplay && window.document.pointerLockElement) {
      // let moving = false;
      const speed = 0.004;
      const velocity = localVector.set(0, 0, 0);
      if (keys.up) {
        velocity.z -= speed * timeDiff;
        // moving = true;
      }
      if (keys.down) {
        velocity.z += speed * timeDiff;
        // moving = true;
      }
      if (keys.left) {
        velocity.x -= speed * timeDiff;
        // moving = true;
      }
      if (keys.right) {
        velocity.x += speed * timeDiff;
        // moving = true;
      }
      if (keys.space) {
        velocity.y += speed * timeDiff;
        // moving = true;
      }
      if (keys.ctrl) {
        velocity.y -= speed * timeDiff;
        // moving = true;
      }

      // if (moving) {
        // velocity.multiplyScalar(Math.pow(moving ? 0.98 : 0.91, timePassed / 5));
        localEuler.setFromQuaternion(fakeXrDisplay.quaternion, localEuler.order);
        localEuler.x = 0;
        fakeXrDisplay.position.add(
          localVector.copy(velocity)
            .applyEuler(localEuler)
        );
        fakeXrDisplay.pushUpdate();
      // }
    }
  };
  _updateMovement();

  lastTime = now;
}

// bootstrap

const _emitLayersVrDisplayActivate = () => {
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];

    if (layer.tagName === 'IFRAME' && layer.d === 3) {
      layer.contentWindow.runAsync('vrdisplayactivate');
    }
  }
};
const _emitLayersExitPresent = () => {
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];

    if (layer.tagName === 'IFRAME' && layer.d === 3) {
      layer.contentWindow.runAsync('exitPresent');
    }
  }
};
const _startFakeVrDisplay = async (width, height) => {
  if (typeof FakeXRDisplay !== 'undefined') {
    fakeXrDisplay = new FakeXRDisplay();
    if (isFinite(width)) {
      fakeXrDisplay.width = width;
    }
    if (isFinite(height)) {
      fakeXrDisplay.height = height;
    }
    fakeXrDisplay.position.set(0, 1.6, 0);
    fakeXrDisplay.pushUpdate();
    fakeXrDisplay.enable();
    await _enterXr();
  } else {
    fakeXrDisplay = {
      position: camera.position,
      quaternion: camera.quaternion,
      get viewMatrix() {
        return camera.matrixWorldInverse.toArray(new Float32Array(16));
      },
      get projectionMatrix() {
        return camera.projectionMatrix.toArray(new Float32Array(16));
      },
      enable() {},
      disable() {},
      pushHmdUpdate(position = this.position, quaternion = this.quaternion) {
        camera.updateMatrixWorld();
      },
      pushGamepadsUpdate(position = this.position, quaternion = this.quaternion) {
        position.toArray(gamepad.pose.position);
        quaternion.toArray(gamepad.pose.orientation);
      },
      pushUpdate() {
        this.pushHmdUpdate();
        this.pushGamepadsUpdate(
          localVector
            .copy(this.position)
            .add(localVector2.set(0.5, -0.3, -0.5).applyQuaternion(this.quaternion))
        );
      },
    };
    fakeXrDisplay.enable();

    renderer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, false);

    const gamepad = {
      hand: 'right',
      pose: {
        position: [0, 0, 0],
        orientation: [0, 0, 0, 1],
      },
      buttons: [
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
        {pressed: false, touched: false},
      ],
      connected: true,
    };
    navigator.getGamepads = () => [null, gamepad];

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, false);
    });
  }

  window.addEventListener('mousedown', e => {
    if (e.button === 0) {
      const gamepads = navigator.getGamepads();
      if (window.document.pointerLockElement) {
        const gamepad = gamepads[1];
        if (gamepad) {
          gamepad.buttons[1].pressed = true;
        }
      } else if (intersectionSpecs[1] || moveSpecs[1]) {
        const gamepad = gamepads[1];
        if (gamepad) {
          gamepad.buttons[1].pressed = true;
        }

        if (orbitControls && ((intersectionSpecs[1] && intersectionSpecs[1].cancel) || moveSpecs[1])) {
          _removeOrbitControls();
        }
      }
    }
  });
  window.addEventListener('mouseup', e => {
    if (e.button === 0) {
      const gamepads = navigator.getGamepads();
      const gamepad = gamepads[1];
      if (gamepad) {
        gamepad.buttons[1].pressed = false;
      }

      if (!window.document.pointerLockElement) {
        _addOrbitControls();
      }
    }
  });
  
  renderer.setAnimationLoop(animate);
};
const _endFakeVrDisplay = async () => {
  renderer.vr.enabled = false;
  // renderer.vr.setSession(null);
  // renderer.vr.setDevice(null);
  renderer.vr.setAnimationLoop(null);

  if (session) {
    await session.end();
    session = null;
  } else if (display) {
    await display.exitPresent();
    display = null;
  }

  fakeXrDisplay.disable();
  fakeXrDisplay = null;

  // renderer.domElement.framebuffer = null; // XXX destroy this framebuffer
};
const _enterXr = async () => {
  if (navigator.xr) { // WebXR
    session = await navigator.xr.requestSession({
      exclusive: true,
    });
    session.layers = layers;

    // console.log('request first frame');
    session.requestAnimationFrame((timestamp, frame) => {
      renderer.vr.setSession(session, {
        frameOfReferenceType: 'stage',
      });

      const pose = frame.getViewerPose();
      const viewport = session.baseLayer.getViewport(pose.views[0]);
      // const width = viewport.width;
      const height = viewport.height;
      const fullWidth = (() => {
        let result = 0;
        for (let i = 0; i < pose.views.length; i++) {
          result += session.baseLayer.getViewport(pose.views[i]).width;
        }
        return result;
      })();
      renderer.setSize(fullWidth, height);
      viewportVector.set(fullWidth, height);

      renderer.setAnimationLoop(null);

      renderer.vr.enabled = true;
      renderer.vr.setSession(session);
      renderer.vr.setAnimationLoop(animate);

      console.log('loaded root in XR');
    });
  } else { // WebVR
    console.log('request device');
    const displays = await navigator.getVRDisplays();
    display = displays[0];

    if (display) {
      console.log('request present');
      await display.requestPresent([
        {
          source: renderer.domElement,
        }
      ]);
      console.log('entered vr');

      display.layers = layers;

      const {renderWidth: width, renderHeight: height} = display.getEyeParameters('left');
      const fullWidth = width * 2;
      renderer.setSize(fullWidth, height);
      viewportVector.set(fullWidth, height);

      renderer.setAnimationLoop(null);
      renderer.vr.enabled = true;
      renderer.vr.setDevice(display);
      renderer.vr.setAnimationLoop(animate);

      console.log('loaded root in XR');
    } else {
      console.log('no vr displays');
    }
  }
};
_startFakeVrDisplay()
  .then(() => {
    _bindEventTarget('ui');

    /* const roomMesh = _makeRoomMesh(0, 0, 0, 0, 0, 0, 0xffee58);
    const roomLinkMesh = _makeRoomLinkMesh(roomLinks.length, roomMesh);
    scene.add(roomLinkMesh);
    roomLinks.push(roomLinkMesh);
    _addVolume(roomMesh); */

    console.log('loaded fake display');
  })
  .catch(err => {
    console.warn(err.stack);
  });

// renderer.setAnimationLoop(animate);
// _openRig(new THREE.Vector3(0, 1.5, -1), new THREE.Quaternion());
})();
    </script>
    <audio src="background.mp3" autoplay loop></audio>
  </body>
</html>
